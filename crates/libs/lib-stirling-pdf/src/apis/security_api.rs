/*
 * Stirling PDF API
 *
 * API documentation for all Server-Side processing. Please note some functionality might be UI only and missing from here.
 *
 * The version of the OpenAPI document: 0.34.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use async_trait::async_trait;
use reqwest;
use std::sync::Arc;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};

#[async_trait]
pub trait SecurityApi: Send + Sync {
    async fn add_password<'file_input, 'owner_password, 'password, 'key_length, 'can_assemble_document, 'can_extract_content, 'can_extract_for_accessibility, 'can_fill_in_form, 'can_modify, 'can_modify_annotations, 'can_print, 'can_print_faithful>(&self, file_input: Option<std::path::PathBuf>, owner_password: Option<&'owner_password str>, password: Option<&'password str>, key_length: Option<i32>, can_assemble_document: Option<bool>, can_extract_content: Option<bool>, can_extract_for_accessibility: Option<bool>, can_fill_in_form: Option<bool>, can_modify: Option<bool>, can_modify_annotations: Option<bool>, can_print: Option<bool>, can_print_faithful: Option<bool>) -> Result<Vec<String>, Error<AddPasswordError>>;
    async fn add_watermark<'watermark_type, 'file_input, 'watermark_text, 'watermark_image, 'alphabet, 'font_size, 'rotation, 'opacity, 'width_spacer, 'height_spacer, 'convert_pdfto_image>(&self, watermark_type: &'watermark_type str, file_input: Option<std::path::PathBuf>, watermark_text: Option<&'watermark_text str>, watermark_image: Option<std::path::PathBuf>, alphabet: Option<&'alphabet str>, font_size: Option<f32>, rotation: Option<f32>, opacity: Option<f32>, width_spacer: Option<i32>, height_spacer: Option<i32>, convert_pdfto_image: Option<bool>) -> Result<Vec<String>, Error<AddWatermarkError>>;
    async fn get_pdf_info<'file_input>(&self, file_input: Option<std::path::PathBuf>) -> Result<Vec<String>, Error<GetPdfInfoError>>;
    async fn redact_pdf<'list_of_text, 'file_input, 'use_regex, 'whole_word_search, 'redact_color, 'custom_padding, 'convert_pdfto_image>(&self, list_of_text: &'list_of_text str, file_input: Option<std::path::PathBuf>, use_regex: Option<bool>, whole_word_search: Option<bool>, redact_color: Option<&'redact_color str>, custom_padding: Option<f64>, convert_pdfto_image: Option<bool>) -> Result<Vec<String>, Error<RedactPdfError>>;
    async fn remove_cert_sign_pdf<'file_input>(&self, file_input: Option<std::path::PathBuf>) -> Result<Vec<String>, Error<RemoveCertSignPdfError>>;
    async fn remove_password<'password, 'file_input>(&self, password: &'password str, file_input: Option<std::path::PathBuf>) -> Result<Vec<String>, Error<RemovePasswordError>>;
    async fn sanitize_pdf<'file_input, 'remove_java_script, 'remove_embedded_files, 'remove_metadata, 'remove_links, 'remove_fonts>(&self, file_input: Option<std::path::PathBuf>, remove_java_script: Option<bool>, remove_embedded_files: Option<bool>, remove_metadata: Option<bool>, remove_links: Option<bool>, remove_fonts: Option<bool>) -> Result<Vec<String>, Error<SanitizePdfError>>;
    async fn sign_pdf_with_cert<'file_input, 'cert_type, 'private_key_file, 'cert_file, 'p12_file, 'jks_file, 'password, 'show_signature, 'reason, 'location, 'name, 'page_number, 'show_logo>(&self, file_input: Option<std::path::PathBuf>, cert_type: Option<&'cert_type str>, private_key_file: Option<std::path::PathBuf>, cert_file: Option<std::path::PathBuf>, p12_file: Option<std::path::PathBuf>, jks_file: Option<std::path::PathBuf>, password: Option<&'password str>, show_signature: Option<bool>, reason: Option<&'reason str>, location: Option<&'location str>, name: Option<&'name str>, page_number: Option<i32>, show_logo: Option<bool>) -> Result<Vec<String>, Error<SignPdfWithCertError>>;
}

pub struct SecurityApiClient {
    configuration: Arc<configuration::Configuration>
}

impl SecurityApiClient {
    pub fn new(configuration: Arc<configuration::Configuration>) -> Self {
        Self { configuration }
    }
}



#[async_trait]
impl SecurityApi for SecurityApiClient {
    /// This endpoint adds password protection to a PDF file. Users can specify a set of permissions that should be applied to the file. Input:PDF Output:PDF
    async fn add_password<'file_input, 'owner_password, 'password, 'key_length, 'can_assemble_document, 'can_extract_content, 'can_extract_for_accessibility, 'can_fill_in_form, 'can_modify, 'can_modify_annotations, 'can_print, 'can_print_faithful>(&self, file_input: Option<std::path::PathBuf>, owner_password: Option<&'owner_password str>, password: Option<&'password str>, key_length: Option<i32>, can_assemble_document: Option<bool>, can_extract_content: Option<bool>, can_extract_for_accessibility: Option<bool>, can_fill_in_form: Option<bool>, can_modify: Option<bool>, can_modify_annotations: Option<bool>, can_print: Option<bool>, can_print_faithful: Option<bool>) -> Result<Vec<String>, Error<AddPasswordError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/api/v1/security/add-password", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        let mut local_var_form = reqwest::multipart::Form::new();
        // TODO: support file upload for 'fileInput' parameter
        if let Some(local_var_param_value) = owner_password {
            local_var_form = local_var_form.text("ownerPassword", local_var_param_value.to_string());
        }
        if let Some(local_var_param_value) = password {
            local_var_form = local_var_form.text("password", local_var_param_value.to_string());
        }
        if let Some(local_var_param_value) = key_length {
            local_var_form = local_var_form.text("keyLength", local_var_param_value.to_string());
        }
        if let Some(local_var_param_value) = can_assemble_document {
            local_var_form = local_var_form.text("canAssembleDocument", local_var_param_value.to_string());
        }
        if let Some(local_var_param_value) = can_extract_content {
            local_var_form = local_var_form.text("canExtractContent", local_var_param_value.to_string());
        }
        if let Some(local_var_param_value) = can_extract_for_accessibility {
            local_var_form = local_var_form.text("canExtractForAccessibility", local_var_param_value.to_string());
        }
        if let Some(local_var_param_value) = can_fill_in_form {
            local_var_form = local_var_form.text("canFillInForm", local_var_param_value.to_string());
        }
        if let Some(local_var_param_value) = can_modify {
            local_var_form = local_var_form.text("canModify", local_var_param_value.to_string());
        }
        if let Some(local_var_param_value) = can_modify_annotations {
            local_var_form = local_var_form.text("canModifyAnnotations", local_var_param_value.to_string());
        }
        if let Some(local_var_param_value) = can_print {
            local_var_form = local_var_form.text("canPrint", local_var_param_value.to_string());
        }
        if let Some(local_var_param_value) = can_print_faithful {
            local_var_form = local_var_form.text("canPrintFaithful", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.multipart(local_var_form);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<AddPasswordError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// This endpoint adds a watermark to a given PDF file. Users can specify the watermark type (text or image), rotation, opacity, width spacer, and height spacer. Input:PDF Output:PDF Type:SISO
    async fn add_watermark<'watermark_type, 'file_input, 'watermark_text, 'watermark_image, 'alphabet, 'font_size, 'rotation, 'opacity, 'width_spacer, 'height_spacer, 'convert_pdfto_image>(&self, watermark_type: &'watermark_type str, file_input: Option<std::path::PathBuf>, watermark_text: Option<&'watermark_text str>, watermark_image: Option<std::path::PathBuf>, alphabet: Option<&'alphabet str>, font_size: Option<f32>, rotation: Option<f32>, opacity: Option<f32>, width_spacer: Option<i32>, height_spacer: Option<i32>, convert_pdfto_image: Option<bool>) -> Result<Vec<String>, Error<AddWatermarkError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/api/v1/security/add-watermark", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        let mut local_var_form = reqwest::multipart::Form::new();
        // TODO: support file upload for 'fileInput' parameter
        local_var_form = local_var_form.text("watermarkType", watermark_type.to_string());
        if let Some(local_var_param_value) = watermark_text {
            local_var_form = local_var_form.text("watermarkText", local_var_param_value.to_string());
        }
        // TODO: support file upload for 'watermarkImage' parameter
        if let Some(local_var_param_value) = alphabet {
            local_var_form = local_var_form.text("alphabet", local_var_param_value.to_string());
        }
        if let Some(local_var_param_value) = font_size {
            local_var_form = local_var_form.text("fontSize", local_var_param_value.to_string());
        }
        if let Some(local_var_param_value) = rotation {
            local_var_form = local_var_form.text("rotation", local_var_param_value.to_string());
        }
        if let Some(local_var_param_value) = opacity {
            local_var_form = local_var_form.text("opacity", local_var_param_value.to_string());
        }
        if let Some(local_var_param_value) = width_spacer {
            local_var_form = local_var_form.text("widthSpacer", local_var_param_value.to_string());
        }
        if let Some(local_var_param_value) = height_spacer {
            local_var_form = local_var_form.text("heightSpacer", local_var_param_value.to_string());
        }
        if let Some(local_var_param_value) = convert_pdfto_image {
            local_var_form = local_var_form.text("convertPDFToImage", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.multipart(local_var_form);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<AddWatermarkError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// desc. Input:PDF Output:JSON Type:SISO
    async fn get_pdf_info<'file_input>(&self, file_input: Option<std::path::PathBuf>) -> Result<Vec<String>, Error<GetPdfInfoError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/api/v1/security/get-info-on-pdf", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        let local_var_form = reqwest::multipart::Form::new();
        // TODO: support file upload for 'fileInput' parameter
        local_var_req_builder = local_var_req_builder.multipart(local_var_form);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<GetPdfInfoError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// This operation takes an input PDF file and redacts the provided listOfText. Input:PDF, Output:PDF, Type:SISO
    async fn redact_pdf<'list_of_text, 'file_input, 'use_regex, 'whole_word_search, 'redact_color, 'custom_padding, 'convert_pdfto_image>(&self, list_of_text: &'list_of_text str, file_input: Option<std::path::PathBuf>, use_regex: Option<bool>, whole_word_search: Option<bool>, redact_color: Option<&'redact_color str>, custom_padding: Option<f64>, convert_pdfto_image: Option<bool>) -> Result<Vec<String>, Error<RedactPdfError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/api/v1/security/auto-redact", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        let mut local_var_form = reqwest::multipart::Form::new();
        // TODO: support file upload for 'fileInput' parameter
        local_var_form = local_var_form.text("listOfText", list_of_text.to_string());
        if let Some(local_var_param_value) = use_regex {
            local_var_form = local_var_form.text("useRegex", local_var_param_value.to_string());
        }
        if let Some(local_var_param_value) = whole_word_search {
            local_var_form = local_var_form.text("wholeWordSearch", local_var_param_value.to_string());
        }
        if let Some(local_var_param_value) = redact_color {
            local_var_form = local_var_form.text("redactColor", local_var_param_value.to_string());
        }
        if let Some(local_var_param_value) = custom_padding {
            local_var_form = local_var_form.text("customPadding", local_var_param_value.to_string());
        }
        if let Some(local_var_param_value) = convert_pdfto_image {
            local_var_form = local_var_form.text("convertPDFToImage", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.multipart(local_var_form);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<RedactPdfError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// This endpoint accepts a PDF file and returns the PDF file without the digital signature. Input: PDF, Output: PDF
    async fn remove_cert_sign_pdf<'file_input>(&self, file_input: Option<std::path::PathBuf>) -> Result<Vec<String>, Error<RemoveCertSignPdfError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/api/v1/security/remove-cert-sign", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        let local_var_form = reqwest::multipart::Form::new();
        // TODO: support file upload for 'fileInput' parameter
        local_var_req_builder = local_var_req_builder.multipart(local_var_form);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<RemoveCertSignPdfError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// This endpoint removes the password from a protected PDF file. Users need to provide the existing password. Input:PDF Output:PDF Type:SISO
    async fn remove_password<'password, 'file_input>(&self, password: &'password str, file_input: Option<std::path::PathBuf>) -> Result<Vec<String>, Error<RemovePasswordError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/api/v1/security/remove-password", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        let mut local_var_form = reqwest::multipart::Form::new();
        // TODO: support file upload for 'fileInput' parameter
        local_var_form = local_var_form.text("password", password.to_string());
        local_var_req_builder = local_var_req_builder.multipart(local_var_form);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<RemovePasswordError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// This endpoint processes a PDF file and removes specific elements based on the provided options. Input:PDF Output:PDF Type:SISO
    async fn sanitize_pdf<'file_input, 'remove_java_script, 'remove_embedded_files, 'remove_metadata, 'remove_links, 'remove_fonts>(&self, file_input: Option<std::path::PathBuf>, remove_java_script: Option<bool>, remove_embedded_files: Option<bool>, remove_metadata: Option<bool>, remove_links: Option<bool>, remove_fonts: Option<bool>) -> Result<Vec<String>, Error<SanitizePdfError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/api/v1/security/sanitize-pdf", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        let mut local_var_form = reqwest::multipart::Form::new();
        // TODO: support file upload for 'fileInput' parameter
        if let Some(local_var_param_value) = remove_java_script {
            local_var_form = local_var_form.text("removeJavaScript", local_var_param_value.to_string());
        }
        if let Some(local_var_param_value) = remove_embedded_files {
            local_var_form = local_var_form.text("removeEmbeddedFiles", local_var_param_value.to_string());
        }
        if let Some(local_var_param_value) = remove_metadata {
            local_var_form = local_var_form.text("removeMetadata", local_var_param_value.to_string());
        }
        if let Some(local_var_param_value) = remove_links {
            local_var_form = local_var_form.text("removeLinks", local_var_param_value.to_string());
        }
        if let Some(local_var_param_value) = remove_fonts {
            local_var_form = local_var_form.text("removeFonts", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.multipart(local_var_form);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<SanitizePdfError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// This endpoint accepts a PDF file, a digital certificate and related information to sign the PDF. It then returns the digitally signed PDF file. Input:PDF Output:PDF Type:SISO
    async fn sign_pdf_with_cert<'file_input, 'cert_type, 'private_key_file, 'cert_file, 'p12_file, 'jks_file, 'password, 'show_signature, 'reason, 'location, 'name, 'page_number, 'show_logo>(&self, file_input: Option<std::path::PathBuf>, cert_type: Option<&'cert_type str>, private_key_file: Option<std::path::PathBuf>, cert_file: Option<std::path::PathBuf>, p12_file: Option<std::path::PathBuf>, jks_file: Option<std::path::PathBuf>, password: Option<&'password str>, show_signature: Option<bool>, reason: Option<&'reason str>, location: Option<&'location str>, name: Option<&'name str>, page_number: Option<i32>, show_logo: Option<bool>) -> Result<Vec<String>, Error<SignPdfWithCertError>> {
        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/api/v1/security/cert-sign", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        let mut local_var_form = reqwest::multipart::Form::new();
        // TODO: support file upload for 'fileInput' parameter
        if let Some(local_var_param_value) = cert_type {
            local_var_form = local_var_form.text("certType", local_var_param_value.to_string());
        }
        // TODO: support file upload for 'privateKeyFile' parameter
        // TODO: support file upload for 'certFile' parameter
        // TODO: support file upload for 'p12File' parameter
        // TODO: support file upload for 'jksFile' parameter
        if let Some(local_var_param_value) = password {
            local_var_form = local_var_form.text("password", local_var_param_value.to_string());
        }
        if let Some(local_var_param_value) = show_signature {
            local_var_form = local_var_form.text("showSignature", local_var_param_value.to_string());
        }
        if let Some(local_var_param_value) = reason {
            local_var_form = local_var_form.text("reason", local_var_param_value.to_string());
        }
        if let Some(local_var_param_value) = location {
            local_var_form = local_var_form.text("location", local_var_param_value.to_string());
        }
        if let Some(local_var_param_value) = name {
            local_var_form = local_var_form.text("name", local_var_param_value.to_string());
        }
        if let Some(local_var_param_value) = page_number {
            local_var_form = local_var_form.text("pageNumber", local_var_param_value.to_string());
        }
        if let Some(local_var_param_value) = show_logo {
            local_var_form = local_var_form.text("showLogo", local_var_param_value.to_string());
        }
        local_var_req_builder = local_var_req_builder.multipart(local_var_form);

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Error::from)
        } else {
            let local_var_entity: Option<SignPdfWithCertError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

}

/// struct for typed errors of method [`add_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddPasswordError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`add_watermark`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddWatermarkError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_pdf_info`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPdfInfoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`redact_pdf`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RedactPdfError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_cert_sign_pdf`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveCertSignPdfError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemovePasswordError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sanitize_pdf`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SanitizePdfError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sign_pdf_with_cert`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SignPdfWithCertError {
    UnknownValue(serde_json::Value),
}

