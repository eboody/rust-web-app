/*
 * Stirling PDF API
 *
 * API documentation for all Server-Side processing. Please note some functionality might be UI only and missing from here.
 *
 * The version of the OpenAPI document: 0.34.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, Error};
use crate::{apis::ResponseContent, models};
use async_trait::async_trait;
use reqwest;
use serde::{Deserialize, Serialize};
use std::sync::Arc;

#[async_trait]
pub trait GeneralApi: Send + Sync {
	async fn auto_split_pdf1<'file_input, 'split_type, 'split_value>(
		&self,
		file_input: Option<std::path::PathBuf>,
		split_type: Option<i32>,
		split_value: Option<&'split_value str>,
	) -> Result<Vec<String>, Error<AutoSplitPdf1Error>>;
	async fn crop_pdf<'file_input, 'x, 'y, 'width, 'height>(
		&self,
		file_input: Option<std::path::PathBuf>,
		x: Option<f64>,
		y: Option<f64>,
		width: Option<f64>,
		height: Option<f64>,
	) -> Result<Vec<String>, Error<CropPdfError>>;
	async fn delete_pages<'file_input, 'page_numbers>(
		&self,
		file_input: Option<std::path::PathBuf>,
		page_numbers: Option<&'page_numbers str>,
	) -> Result<Vec<String>, Error<DeletePagesError>>;
	async fn merge_multiple_pages_into_one<
		'file_input,
		'pages_per_sheet,
		'add_border,
	>(
		&self,
		file_input: Option<std::path::PathBuf>,
		pages_per_sheet: Option<i32>,
		add_border: Option<bool>,
	) -> Result<Vec<String>, Error<MergeMultiplePagesIntoOneError>>;
	async fn merge_pdfs<'file_input, 'sort_type, 'remove_cert_sign>(
		&self,
		file_input: Option<Vec<std::path::PathBuf>>,
		sort_type: Option<&'sort_type str>,
		remove_cert_sign: Option<bool>,
	) -> Result<Vec<String>, Error<MergePdfsError>>;
	async fn overlay_pdfs<
		'overlay_mode,
		'file_input,
		'overlay_files,
		'counts,
		'overlay_position,
	>(
		&self,
		overlay_mode: &'overlay_mode str,
		file_input: Option<std::path::PathBuf>,
		overlay_files: Option<Vec<std::path::PathBuf>>,
		counts: Option<Vec<i32>>,
		overlay_position: Option<i32>,
	) -> Result<Vec<String>, Error<OverlayPdfsError>>;
	async fn pdf_to_single_page<'file_input>(
		&self,
		file_input: Option<std::path::PathBuf>,
	) -> Result<Vec<String>, Error<PdfToSinglePageError>>;
	async fn rearrange_pages<'file_input, 'page_numbers, 'custom_mode>(
		&self,
		file_input: Option<std::path::PathBuf>,
		page_numbers: Option<&'page_numbers str>,
		custom_mode: Option<&'custom_mode str>,
	) -> Result<Vec<String>, Error<RearrangePagesError>>;
	async fn remove_images<'file_input>(
		&self,
		file_input: Option<std::path::PathBuf>,
	) -> Result<Vec<String>, Error<RemoveImagesError>>;
	async fn rotate_pdf<'file_input, 'angle>(
		&self,
		file_input: Option<std::path::PathBuf>,
		angle: Option<i32>,
	) -> Result<Vec<String>, Error<RotatePdfError>>;
	async fn scale_pages<'file_input, 'page_size, 'scale_factor>(
		&self,
		file_input: Option<std::path::PathBuf>,
		page_size: Option<&'page_size str>,
		scale_factor: Option<f32>,
	) -> Result<Vec<String>, Error<ScalePagesError>>;
	async fn split_pdf<
		'file_input,
		'horizontal_divisions,
		'vertical_divisions,
		'merge,
	>(
		&self,
		file_input: Option<std::path::PathBuf>,
		horizontal_divisions: Option<i32>,
		vertical_divisions: Option<i32>,
		merge: Option<bool>,
	) -> Result<Vec<String>, Error<SplitPdfError>>;
	async fn split_pdf1<
		'file_input,
		'include_metadata,
		'allow_duplicates,
		'bookmark_level,
	>(
		&self,
		file_input: Option<std::path::PathBuf>,
		include_metadata: Option<bool>,
		allow_duplicates: Option<bool>,
		bookmark_level: Option<i32>,
	) -> Result<Vec<String>, Error<SplitPdf1Error>>;
	async fn split_pdf2<'file_input, 'page_numbers>(
		&self,
		file_input: Option<std::path::PathBuf>,
		page_numbers: Option<&'page_numbers str>,
	) -> Result<Vec<String>, Error<SplitPdf2Error>>;
}

pub struct GeneralApiClient {
	configuration: Arc<configuration::Configuration>,
}

impl GeneralApiClient {
	pub fn new(configuration: Arc<configuration::Configuration>) -> Self {
		Self { configuration }
	}
}

#[async_trait]
impl GeneralApi for GeneralApiClient {
	/// split PDF into multiple paged documents based on size/count, ie if 20 pages and split into 5, it does 5 documents each 4 pages   if 10MB and each page is 1MB and you enter 2MB then 5 docs each 2MB (rounded so that it accepts 1.9MB but not 2.1MB) Input:PDF Output:ZIP-PDF Type:SISO
	async fn auto_split_pdf1<'file_input, 'split_type, 'split_value>(
		&self,
		file_input: Option<std::path::PathBuf>,
		split_type: Option<i32>,
		split_value: Option<&'split_value str>,
	) -> Result<Vec<String>, Error<AutoSplitPdf1Error>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/api/v1/general/split-by-size-or-count",
			local_var_configuration.base_path
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		let mut local_var_form = reqwest::multipart::Form::new();
		// TODO: support file upload for 'fileInput' parameter
		if let Some(local_var_param_value) = split_type {
			local_var_form =
				local_var_form.text("splitType", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = split_value {
			local_var_form =
				local_var_form.text("splitValue", local_var_param_value.to_string());
		}
		local_var_req_builder = local_var_req_builder.multipart(local_var_form);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<AutoSplitPdf1Error> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// This operation takes an input PDF file and crops it according to the given coordinates. Input:PDF Output:PDF Type:SISO
	async fn crop_pdf<'file_input, 'x, 'y, 'width, 'height>(
		&self,
		file_input: Option<std::path::PathBuf>,
		x: Option<f64>,
		y: Option<f64>,
		width: Option<f64>,
		height: Option<f64>,
	) -> Result<Vec<String>, Error<CropPdfError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str =
			format!("{}/api/v1/general/crop", local_var_configuration.base_path);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		let mut local_var_form = reqwest::multipart::Form::new();
		// TODO: support file upload for 'fileInput' parameter
		if let Some(local_var_param_value) = x {
			local_var_form =
				local_var_form.text("x", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = y {
			local_var_form =
				local_var_form.text("y", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = width {
			local_var_form =
				local_var_form.text("width", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = height {
			local_var_form =
				local_var_form.text("height", local_var_param_value.to_string());
		}
		local_var_req_builder = local_var_req_builder.multipart(local_var_form);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<CropPdfError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// This endpoint removes specified pages from a given PDF file. Users can provide a comma-separated list of page numbers or ranges to delete. Input:PDF Output:PDF Type:SISO
	async fn delete_pages<'file_input, 'page_numbers>(
		&self,
		file_input: Option<std::path::PathBuf>,
		page_numbers: Option<&'page_numbers str>,
	) -> Result<Vec<String>, Error<DeletePagesError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/api/v1/general/remove-pages",
			local_var_configuration.base_path
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		let mut local_var_form = reqwest::multipart::Form::new();
		// TODO: support file upload for 'fileInput' parameter
		if let Some(local_var_param_value) = page_numbers {
			local_var_form = local_var_form
				.text("pageNumbers", local_var_param_value.to_string());
		}
		local_var_req_builder = local_var_req_builder.multipart(local_var_form);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<DeletePagesError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// This operation takes an input PDF file and the number of pages to merge into a single sheet in the output PDF file. Input:PDF Output:PDF Type:SISO
	async fn merge_multiple_pages_into_one<
		'file_input,
		'pages_per_sheet,
		'add_border,
	>(
		&self,
		file_input: Option<std::path::PathBuf>,
		pages_per_sheet: Option<i32>,
		add_border: Option<bool>,
	) -> Result<Vec<String>, Error<MergeMultiplePagesIntoOneError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/api/v1/general/multi-page-layout",
			local_var_configuration.base_path
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		let mut local_var_form = reqwest::multipart::Form::new();
		// TODO: support file upload for 'fileInput' parameter
		if let Some(local_var_param_value) = pages_per_sheet {
			local_var_form = local_var_form
				.text("pagesPerSheet", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = add_border {
			local_var_form =
				local_var_form.text("addBorder", local_var_param_value.to_string());
		}
		local_var_req_builder = local_var_req_builder.multipart(local_var_form);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<MergeMultiplePagesIntoOneError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// This endpoint merges multiple PDF files into a single PDF file. The merged file will contain all pages from the input files in the order they were provided. Input:PDF Output:PDF Type:MISO
	async fn merge_pdfs<'file_input, 'sort_type, 'remove_cert_sign>(
		&self,
		file_input: Option<Vec<std::path::PathBuf>>,
		sort_type: Option<&'sort_type str>,
		remove_cert_sign: Option<bool>,
	) -> Result<Vec<String>, Error<MergePdfsError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/api/v1/general/merge-pdfs",
			local_var_configuration.base_path
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		let mut local_var_form = reqwest::multipart::Form::new();
		// TODO: support file upload for 'fileInput' parameter
		if let Some(local_var_param_value) = sort_type {
			local_var_form =
				local_var_form.text("sortType", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = remove_cert_sign {
			local_var_form = local_var_form
				.text("removeCertSign", local_var_param_value.to_string());
		}
		local_var_req_builder = local_var_req_builder.multipart(local_var_form);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<MergePdfsError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Overlay PDF files onto a base PDF with different modes: Sequential, Interleaved, or Fixed Repeat. Input:PDF Output:PDF Type:MIMO
	async fn overlay_pdfs<
		'overlay_mode,
		'file_input,
		'overlay_files,
		'counts,
		'overlay_position,
	>(
		&self,
		overlay_mode: &'overlay_mode str,
		file_input: Option<std::path::PathBuf>,
		overlay_files: Option<Vec<std::path::PathBuf>>,
		counts: Option<Vec<i32>>,
		overlay_position: Option<i32>,
	) -> Result<Vec<String>, Error<OverlayPdfsError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/api/v1/general/overlay-pdfs",
			local_var_configuration.base_path
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		let mut local_var_form = reqwest::multipart::Form::new();
		// TODO: support file upload for 'fileInput' parameter
		// TODO: support file upload for 'overlayFiles' parameter
		local_var_form =
			local_var_form.text("overlayMode", overlay_mode.to_string());
		if let Some(local_var_param_value) = counts {
			local_var_form = local_var_form.text(
				"counts",
				local_var_param_value
					.into_iter()
					.map(|p| p.to_string())
					.collect::<Vec<String>>()
					.join(",")
					.to_string(),
			);
		}
		if let Some(local_var_param_value) = overlay_position {
			local_var_form = local_var_form
				.text("overlayPosition", local_var_param_value.to_string());
		}
		local_var_req_builder = local_var_req_builder.multipart(local_var_form);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<OverlayPdfsError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// This endpoint converts a multi-page PDF document into a single paged PDF document. The width of the single page will be same as the input's width, but the height will be the sum of all the pages' heights. Input:PDF Output:PDF Type:SISO
	async fn pdf_to_single_page<'file_input>(
		&self,
		file_input: Option<std::path::PathBuf>,
	) -> Result<Vec<String>, Error<PdfToSinglePageError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/api/v1/general/pdf-to-single-page",
			local_var_configuration.base_path
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		let local_var_form = reqwest::multipart::Form::new();
		// TODO: support file upload for 'fileInput' parameter
		local_var_req_builder = local_var_req_builder.multipart(local_var_form);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<PdfToSinglePageError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// This endpoint rearranges pages in a given PDF file based on the specified page order or custom mode. Users can provide a page order as a comma-separated list of page numbers or page ranges, or a custom mode. Input:PDF Output:PDF
	async fn rearrange_pages<'file_input, 'page_numbers, 'custom_mode>(
		&self,
		file_input: Option<std::path::PathBuf>,
		page_numbers: Option<&'page_numbers str>,
		custom_mode: Option<&'custom_mode str>,
	) -> Result<Vec<String>, Error<RearrangePagesError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/api/v1/general/rearrange-pages",
			local_var_configuration.base_path
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		let mut local_var_form = reqwest::multipart::Form::new();
		// TODO: support file upload for 'fileInput' parameter
		if let Some(local_var_param_value) = page_numbers {
			local_var_form = local_var_form
				.text("pageNumbers", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = custom_mode {
			local_var_form =
				local_var_form.text("customMode", local_var_param_value.to_string());
		}
		local_var_req_builder = local_var_req_builder.multipart(local_var_form);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<RearrangePagesError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// This endpoint remove images from file to reduce the file size.Input:PDF Output:PDF Type:MISO
	async fn remove_images<'file_input>(
		&self,
		file_input: Option<std::path::PathBuf>,
	) -> Result<Vec<String>, Error<RemoveImagesError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/api/v1/general/remove-image-pdf",
			local_var_configuration.base_path
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		let local_var_form = reqwest::multipart::Form::new();
		// TODO: support file upload for 'fileInput' parameter
		local_var_req_builder = local_var_req_builder.multipart(local_var_form);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<RemoveImagesError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// This endpoint rotates a given PDF file by a specified angle. The angle must be a multiple of 90. Input:PDF Output:PDF Type:SISO
	async fn rotate_pdf<'file_input, 'angle>(
		&self,
		file_input: Option<std::path::PathBuf>,
		angle: Option<i32>,
	) -> Result<Vec<String>, Error<RotatePdfError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/api/v1/general/rotate-pdf",
			local_var_configuration.base_path
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		let mut local_var_form = reqwest::multipart::Form::new();
		// TODO: support file upload for 'fileInput' parameter
		if let Some(local_var_param_value) = angle {
			local_var_form =
				local_var_form.text("angle", local_var_param_value.to_string());
		}
		local_var_req_builder = local_var_req_builder.multipart(local_var_form);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<RotatePdfError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// This operation takes an input PDF file and the size to scale the pages to in the output PDF file. Input:PDF Output:PDF Type:SISO
	async fn scale_pages<'file_input, 'page_size, 'scale_factor>(
		&self,
		file_input: Option<std::path::PathBuf>,
		page_size: Option<&'page_size str>,
		scale_factor: Option<f32>,
	) -> Result<Vec<String>, Error<ScalePagesError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/api/v1/general/scale-pages",
			local_var_configuration.base_path
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		let mut local_var_form = reqwest::multipart::Form::new();
		// TODO: support file upload for 'fileInput' parameter
		if let Some(local_var_param_value) = page_size {
			local_var_form =
				local_var_form.text("pageSize", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = scale_factor {
			local_var_form = local_var_form
				.text("scaleFactor", local_var_param_value.to_string());
		}
		local_var_req_builder = local_var_req_builder.multipart(local_var_form);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<ScalePagesError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Split each page of a PDF into smaller sections based on the user's choice (halves, thirds, quarters, etc.), both vertically and horizontally. Input:PDF Output:ZIP-PDF Type:SISO
	async fn split_pdf<
		'file_input,
		'horizontal_divisions,
		'vertical_divisions,
		'merge,
	>(
		&self,
		file_input: Option<std::path::PathBuf>,
		horizontal_divisions: Option<i32>,
		vertical_divisions: Option<i32>,
		merge: Option<bool>,
	) -> Result<Vec<String>, Error<SplitPdfError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/api/v1/general/split-pdf-by-sections",
			local_var_configuration.base_path
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		let mut local_var_form = reqwest::multipart::Form::new();
		// TODO: support file upload for 'fileInput' parameter
		if let Some(local_var_param_value) = horizontal_divisions {
			local_var_form = local_var_form
				.text("horizontalDivisions", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = vertical_divisions {
			local_var_form = local_var_form
				.text("verticalDivisions", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = merge {
			local_var_form =
				local_var_form.text("merge", local_var_param_value.to_string());
		}
		local_var_req_builder = local_var_req_builder.multipart(local_var_form);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<SplitPdfError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Splits a PDF into chapters and returns a ZIP file.
	async fn split_pdf1<
		'file_input,
		'include_metadata,
		'allow_duplicates,
		'bookmark_level,
	>(
		&self,
		file_input: Option<std::path::PathBuf>,
		include_metadata: Option<bool>,
		allow_duplicates: Option<bool>,
		bookmark_level: Option<i32>,
	) -> Result<Vec<String>, Error<SplitPdf1Error>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/api/v1/general/split-pdf-by-chapters",
			local_var_configuration.base_path
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		let mut local_var_form = reqwest::multipart::Form::new();
		// TODO: support file upload for 'fileInput' parameter
		if let Some(local_var_param_value) = include_metadata {
			local_var_form = local_var_form
				.text("includeMetadata", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = allow_duplicates {
			local_var_form = local_var_form
				.text("allowDuplicates", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = bookmark_level {
			local_var_form = local_var_form
				.text("bookmarkLevel", local_var_param_value.to_string());
		}
		local_var_req_builder = local_var_req_builder.multipart(local_var_form);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<SplitPdf1Error> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// This endpoint splits a given PDF file into separate documents based on the specified page numbers or ranges. Users can specify pages using individual numbers, ranges, or 'all' for every page. Input:PDF Output:PDF Type:SIMO
	async fn split_pdf2<'file_input, 'page_numbers>(
		&self,
		file_input: Option<std::path::PathBuf>,
		page_numbers: Option<&'page_numbers str>,
	) -> Result<Vec<String>, Error<SplitPdf2Error>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/api/v1/general/split-pages",
			local_var_configuration.base_path
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		let mut local_var_form = reqwest::multipart::Form::new();
		// TODO: support file upload for 'fileInput' parameter
		if let Some(local_var_param_value) = page_numbers {
			local_var_form = local_var_form
				.text("pageNumbers", local_var_param_value.to_string());
		}
		local_var_req_builder = local_var_req_builder.multipart(local_var_form);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<SplitPdf2Error> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}
}

/// struct for typed errors of method [`auto_split_pdf1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AutoSplitPdf1Error {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`crop_pdf`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CropPdfError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_pages`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeletePagesError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`merge_multiple_pages_into_one`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MergeMultiplePagesIntoOneError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`merge_pdfs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MergePdfsError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`overlay_pdfs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OverlayPdfsError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pdf_to_single_page`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PdfToSinglePageError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rearrange_pages`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RearrangePagesError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_images`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveImagesError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rotate_pdf`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RotatePdfError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`scale_pages`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ScalePagesError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`split_pdf`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SplitPdfError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`split_pdf1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SplitPdf1Error {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`split_pdf2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SplitPdf2Error {
	UnknownValue(serde_json::Value),
}
