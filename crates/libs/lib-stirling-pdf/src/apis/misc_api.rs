/*
 * Stirling PDF API
 *
 * API documentation for all Server-Side processing. Please note some functionality might be UI only and missing from here.
 *
 * The version of the OpenAPI document: 0.34.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize};
use serde_json::to_value;

/// struct for typed errors of method [`add_page_numbers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddPageNumbersError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`add_stamp`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddStampError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auto_split_pdf`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AutoSplitPdfError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`extract_header`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExtractHeaderError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`extract_header1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExtractHeader1Error {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`extract_image_scans`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExtractImageScansError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`extract_images`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExtractImagesError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`flatten`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FlattenError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`optimize_pdf`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OptimizePdfError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`overlay_image`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OverlayImageError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`process_pdf_with_ocr`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProcessPdfWithOcrError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_blank_pages`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveBlankPagesError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repair_pdf`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepairPdfError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`replace_and_invert_color`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReplaceAndInvertColorError {
	UnknownValue(serde_json::Value),
}

/// This operation takes an input PDF file and adds page numbers to it. Input:PDF Output:PDF Type:SISO
pub async fn add_page_numbers(
	configuration: &configuration::Configuration,
	file_input: Option<std::path::PathBuf>,
	page_numbers: Option<&str>,
	custom_margin: Option<&str>,
	font_size: Option<f32>,
	font_type: Option<&str>,
	position: Option<i32>,
	starting_number: Option<i32>,
	pages_to_number: Option<&str>,
	custom_text: Option<&str>,
) -> Result<Vec<String>, Error<AddPageNumbersError>> {
	let local_var_configuration = configuration;

	let local_var_client = &local_var_configuration.client;

	let local_var_uri_str = format!(
		"{}/api/v1/misc/add-page-numbers",
		local_var_configuration.base_path
	);
	let mut local_var_req_builder =
		local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

	if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
		local_var_req_builder = local_var_req_builder
			.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
	}
	let mut local_var_form = reqwest::multipart::Form::new();
	// TODO: support file upload for 'fileInput' parameter
	if let Some(local_var_param_value) = page_numbers {
		local_var_form =
			local_var_form.text("pageNumbers", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = custom_margin {
		local_var_form =
			local_var_form.text("customMargin", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = font_size {
		local_var_form =
			local_var_form.text("fontSize", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = font_type {
		local_var_form =
			local_var_form.text("fontType", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = position {
		local_var_form =
			local_var_form.text("position", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = starting_number {
		local_var_form =
			local_var_form.text("startingNumber", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = pages_to_number {
		local_var_form =
			local_var_form.text("pagesToNumber", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = custom_text {
		local_var_form =
			local_var_form.text("customText", local_var_param_value.to_string());
	}
	local_var_req_builder = local_var_req_builder.multipart(local_var_form);

	let local_var_req = local_var_req_builder.build()?;
	let local_var_resp = local_var_client.execute(local_var_req).await?;

	let local_var_status = local_var_resp.status();
	let local_var_content = local_var_resp.text().await?;

	if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
		serde_json::from_str(&local_var_content).map_err(Error::from)
	} else {
		let local_var_entity: Option<AddPageNumbersError> =
			serde_json::from_str(&local_var_content).ok();
		let local_var_error = ResponseContent {
			status: local_var_status,
			content: local_var_content,
			entity: local_var_entity,
		};
		Err(Error::ResponseError(local_var_error))
	}
}

/// This endpoint adds a stamp to a given PDF file. Users can specify the stamp type (text or image), rotation, opacity, width spacer, and height spacer. Input:PDF Output:PDF Type:SISO
pub async fn add_stamp(
	configuration: &configuration::Configuration,
	stamp_type: &str,
	file_input: Option<std::path::PathBuf>,
	page_numbers: Option<&str>,
	stamp_text: Option<&str>,
	stamp_image: Option<std::path::PathBuf>,
	alphabet: Option<&str>,
	font_size: Option<f32>,
	rotation: Option<f32>,
	opacity: Option<f32>,
	position: Option<i32>,
	override_x: Option<f32>,
	override_y: Option<f32>,
	custom_margin: Option<&str>,
	custom_color: Option<&str>,
) -> Result<Vec<String>, Error<AddStampError>> {
	let local_var_configuration = configuration;

	let local_var_client = &local_var_configuration.client;

	let local_var_uri_str = format!(
		"{}/api/v1/misc/add-stamp",
		local_var_configuration.base_path
	);
	let mut local_var_req_builder =
		local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

	if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
		local_var_req_builder = local_var_req_builder
			.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
	}
	let mut local_var_form = reqwest::multipart::Form::new();
	// TODO: support file upload for 'fileInput' parameter
	if let Some(local_var_param_value) = page_numbers {
		local_var_form =
			local_var_form.text("pageNumbers", local_var_param_value.to_string());
	}
	local_var_form = local_var_form.text("stampType", stamp_type.to_string());
	if let Some(local_var_param_value) = stamp_text {
		local_var_form =
			local_var_form.text("stampText", local_var_param_value.to_string());
	}
	// TODO: support file upload for 'stampImage' parameter
	if let Some(local_var_param_value) = alphabet {
		local_var_form =
			local_var_form.text("alphabet", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = font_size {
		local_var_form =
			local_var_form.text("fontSize", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = rotation {
		local_var_form =
			local_var_form.text("rotation", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = opacity {
		local_var_form =
			local_var_form.text("opacity", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = position {
		local_var_form =
			local_var_form.text("position", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = override_x {
		local_var_form =
			local_var_form.text("overrideX", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = override_y {
		local_var_form =
			local_var_form.text("overrideY", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = custom_margin {
		local_var_form =
			local_var_form.text("customMargin", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = custom_color {
		local_var_form =
			local_var_form.text("customColor", local_var_param_value.to_string());
	}
	local_var_req_builder = local_var_req_builder.multipart(local_var_form);

	let local_var_req = local_var_req_builder.build()?;
	let local_var_resp = local_var_client.execute(local_var_req).await?;

	let local_var_status = local_var_resp.status();
	let local_var_content = local_var_resp.text().await?;

	if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
		serde_json::from_str(&local_var_content).map_err(Error::from)
	} else {
		let local_var_entity: Option<AddStampError> =
			serde_json::from_str(&local_var_content).ok();
		let local_var_error = ResponseContent {
			status: local_var_status,
			content: local_var_content,
			entity: local_var_entity,
		};
		Err(Error::ResponseError(local_var_error))
	}
}

/// This endpoint accepts a PDF file, scans each page for a specific QR code, and splits the document at the QR code boundaries. The output is a zip file containing each separate PDF document. Input:PDF Output:ZIP-PDF Type:SISO
pub async fn auto_split_pdf(
	configuration: &configuration::Configuration,
	file_input: Option<std::path::PathBuf>,
	duplex_mode: Option<bool>,
) -> Result<Vec<String>, Error<AutoSplitPdfError>> {
	let local_var_configuration = configuration;

	let local_var_client = &local_var_configuration.client;

	let local_var_uri_str = format!(
		"{}/api/v1/misc/auto-split-pdf",
		local_var_configuration.base_path
	);
	let mut local_var_req_builder =
		local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

	if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
		local_var_req_builder = local_var_req_builder
			.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
	}
	let mut local_var_form = reqwest::multipart::Form::new();
	// TODO: support file upload for 'fileInput' parameter
	if let Some(local_var_param_value) = duplex_mode {
		local_var_form =
			local_var_form.text("duplexMode", local_var_param_value.to_string());
	}
	local_var_req_builder = local_var_req_builder.multipart(local_var_form);

	let local_var_req = local_var_req_builder.build()?;
	let local_var_resp = local_var_client.execute(local_var_req).await?;

	let local_var_status = local_var_resp.status();
	let local_var_content = local_var_resp.text().await?;

	if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
		serde_json::from_str(&local_var_content).map_err(Error::from)
	} else {
		let local_var_entity: Option<AutoSplitPdfError> =
			serde_json::from_str(&local_var_content).ok();
		let local_var_error = ResponseContent {
			status: local_var_status,
			content: local_var_content,
			entity: local_var_entity,
		};
		Err(Error::ResponseError(local_var_error))
	}
}

/// desc. Input:PDF Output:JS Type:SISO
pub async fn extract_header(
	configuration: &configuration::Configuration,
	file_input: Option<std::path::PathBuf>,
) -> Result<Vec<String>, Error<ExtractHeaderError>> {
	let local_var_configuration = configuration;

	let local_var_client = &local_var_configuration.client;

	let local_var_uri_str = format!(
		"{}/api/v1/misc/show-javascript",
		local_var_configuration.base_path
	);
	let mut local_var_req_builder =
		local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

	if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
		local_var_req_builder = local_var_req_builder
			.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
	}
	let mut local_var_form = reqwest::multipart::Form::new();
	// TODO: support file upload for 'fileInput' parameter
	local_var_req_builder = local_var_req_builder.multipart(local_var_form);

	let local_var_req = local_var_req_builder.build()?;
	let local_var_resp = local_var_client.execute(local_var_req).await?;

	let local_var_status = local_var_resp.status();
	let local_var_content = local_var_resp.text().await?;

	if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
		serde_json::from_str(&local_var_content).map_err(Error::from)
	} else {
		let local_var_entity: Option<ExtractHeaderError> =
			serde_json::from_str(&local_var_content).ok();
		let local_var_error = ResponseContent {
			status: local_var_status,
			content: local_var_content,
			entity: local_var_entity,
		};
		Err(Error::ResponseError(local_var_error))
	}
}

/// This endpoint accepts a PDF file and attempts to extract its title or header based on heuristics. Input:PDF Output:PDF Type:SISO
pub async fn extract_header1(
	configuration: &configuration::Configuration,
	file_input: Option<std::path::PathBuf>,
	use_first_text_as_fallback: Option<bool>,
) -> Result<Vec<String>, Error<ExtractHeader1Error>> {
	let local_var_configuration = configuration;

	let local_var_client = &local_var_configuration.client;

	let local_var_uri_str = format!(
		"{}/api/v1/misc/auto-rename",
		local_var_configuration.base_path
	);
	let mut local_var_req_builder =
		local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

	if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
		local_var_req_builder = local_var_req_builder
			.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
	}
	let mut local_var_form = reqwest::multipart::Form::new();
	// TODO: support file upload for 'fileInput' parameter
	if let Some(local_var_param_value) = use_first_text_as_fallback {
		local_var_form = local_var_form
			.text("useFirstTextAsFallback", local_var_param_value.to_string());
	}
	local_var_req_builder = local_var_req_builder.multipart(local_var_form);

	let local_var_req = local_var_req_builder.build()?;
	let local_var_resp = local_var_client.execute(local_var_req).await?;

	let local_var_status = local_var_resp.status();
	let local_var_content = local_var_resp.text().await?;

	if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
		serde_json::from_str(&local_var_content).map_err(Error::from)
	} else {
		let local_var_entity: Option<ExtractHeader1Error> =
			serde_json::from_str(&local_var_content).ok();
		let local_var_error = ResponseContent {
			status: local_var_status,
			content: local_var_content,
			entity: local_var_entity,
		};
		Err(Error::ResponseError(local_var_error))
	}
}

/// This endpoint extracts image scans from a given file based on certain parameters. Users can specify angle threshold, tolerance, minimum area, minimum contour area, and border size. Input:PDF Output:IMAGE/ZIP Type:SIMO
pub async fn extract_image_scans(
	configuration: &configuration::Configuration,
	file_input: std::path::PathBuf,
	angle_threshold: Option<i32>,
	tolerance: Option<i32>,
	min_area: Option<i32>,
	min_contour_area: Option<i32>,
	border_size: Option<i32>,
) -> Result<Vec<String>, Error<ExtractImageScansError>> {
	let local_var_configuration = configuration;

	let local_var_client = &local_var_configuration.client;

	let local_var_uri_str = format!(
		"{}/api/v1/misc/extract-image-scans",
		local_var_configuration.base_path
	);
	let mut local_var_req_builder =
		local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

	if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
		local_var_req_builder = local_var_req_builder
			.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
	}
	let mut local_var_form = reqwest::multipart::Form::new();
	// TODO: support file upload for 'fileInput' parameter
	if let Some(local_var_param_value) = angle_threshold {
		local_var_form =
			local_var_form.text("angleThreshold", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = tolerance {
		local_var_form =
			local_var_form.text("tolerance", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = min_area {
		local_var_form =
			local_var_form.text("minArea", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = min_contour_area {
		local_var_form =
			local_var_form.text("minContourArea", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = border_size {
		local_var_form =
			local_var_form.text("borderSize", local_var_param_value.to_string());
	}
	local_var_req_builder = local_var_req_builder.multipart(local_var_form);

	let local_var_req = local_var_req_builder.build()?;
	let local_var_resp = local_var_client.execute(local_var_req).await?;

	let local_var_status = local_var_resp.status();
	let local_var_content = local_var_resp.text().await?;

	if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
		serde_json::from_str(&local_var_content).map_err(Error::from)
	} else {
		let local_var_entity: Option<ExtractImageScansError> =
			serde_json::from_str(&local_var_content).ok();
		let local_var_error = ResponseContent {
			status: local_var_status,
			content: local_var_content,
			entity: local_var_entity,
		};
		Err(Error::ResponseError(local_var_error))
	}
}

/// This endpoint extracts images from a given PDF file and returns them in a zip file. Users can specify the output image format. Input: PDF Output: IMAGE/ZIP Type: SIMO
pub async fn extract_images(
	configuration: &configuration::Configuration,
	file_input: Option<std::path::PathBuf>,
	format: Option<&str>,
	allow_duplicates: Option<bool>,
) -> Result<Vec<String>, Error<ExtractImagesError>> {
	let local_var_configuration = configuration;

	let local_var_client = &local_var_configuration.client;

	let local_var_uri_str = format!(
		"{}/api/v1/misc/extract-images",
		local_var_configuration.base_path
	);
	let mut local_var_req_builder =
		local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

	if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
		local_var_req_builder = local_var_req_builder
			.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
	}
	let mut local_var_form = reqwest::multipart::Form::new();
	// TODO: support file upload for 'fileInput' parameter
	if let Some(local_var_param_value) = format {
		local_var_form =
			local_var_form.text("format", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = allow_duplicates {
		local_var_form = local_var_form
			.text("allowDuplicates", local_var_param_value.to_string());
	}
	local_var_req_builder = local_var_req_builder.multipart(local_var_form);

	let local_var_req = local_var_req_builder.build()?;
	let local_var_resp = local_var_client.execute(local_var_req).await?;

	let local_var_status = local_var_resp.status();
	let local_var_content = local_var_resp.text().await?;

	if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
		serde_json::from_str(&local_var_content).map_err(Error::from)
	} else {
		let local_var_entity: Option<ExtractImagesError> =
			serde_json::from_str(&local_var_content).ok();
		let local_var_error = ResponseContent {
			status: local_var_status,
			content: local_var_content,
			entity: local_var_entity,
		};
		Err(Error::ResponseError(local_var_error))
	}
}

/// Flattening just PDF form fields or converting each page to images to make text unselectable. Input: PDF, Output: PDF. Type: SISO
pub async fn flatten(
	configuration: &configuration::Configuration,
	file_input: Option<std::path::PathBuf>,
	flatten_only_forms: Option<bool>,
) -> Result<Vec<String>, Error<FlattenError>> {
	let local_var_configuration = configuration;

	let local_var_client = &local_var_configuration.client;

	let local_var_uri_str =
		format!("{}/api/v1/misc/flatten", local_var_configuration.base_path);
	let mut local_var_req_builder =
		local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

	if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
		local_var_req_builder = local_var_req_builder
			.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
	}
	let mut local_var_form = reqwest::multipart::Form::new();
	// TODO: support file upload for 'fileInput' parameter
	if let Some(local_var_param_value) = flatten_only_forms {
		local_var_form = local_var_form
			.text("flattenOnlyForms", local_var_param_value.to_string());
	}
	local_var_req_builder = local_var_req_builder.multipart(local_var_form);

	let local_var_req = local_var_req_builder.build()?;
	let local_var_resp = local_var_client.execute(local_var_req).await?;

	let local_var_status = local_var_resp.status();
	let local_var_content = local_var_resp.text().await?;

	if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
		serde_json::from_str(&local_var_content).map_err(Error::from)
	} else {
		let local_var_entity: Option<FlattenError> =
			serde_json::from_str(&local_var_content).ok();
		let local_var_error = ResponseContent {
			status: local_var_status,
			content: local_var_content,
			entity: local_var_entity,
		};
		Err(Error::ResponseError(local_var_error))
	}
}

/// This endpoint allows you to update the metadata of a given PDF file. You can add, modify, or delete standard and custom metadata fields. Input:PDF Output:PDF Type:SISO
pub async fn metadata(
	configuration: &configuration::Configuration,
	file_input: Option<std::path::PathBuf>,
	delete_all: Option<bool>,
	author: Option<&str>,
	creation_date: Option<&str>,
	creator: Option<&str>,
	keywords: Option<&str>,
	modification_date: Option<&str>,
	producer: Option<&str>,
	subject: Option<&str>,
	title: Option<&str>,
	trapped: Option<&str>,
	all_request_params: Option<std::collections::HashMap<String, String>>,
) -> Result<Vec<String>, Error<MetadataError>> {
	let local_var_configuration = configuration;

	let local_var_client = &local_var_configuration.client;

	let local_var_uri_str = format!(
		"{}/api/v1/misc/update-metadata",
		local_var_configuration.base_path
	);
	let mut local_var_req_builder =
		local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

	if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
		local_var_req_builder = local_var_req_builder
			.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
	}
	let mut local_var_form = reqwest::multipart::Form::new();
	// TODO: support file upload for 'fileInput' parameter
	if let Some(local_var_param_value) = delete_all {
		local_var_form =
			local_var_form.text("deleteAll", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = author {
		local_var_form =
			local_var_form.text("author", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = creation_date {
		local_var_form =
			local_var_form.text("creationDate", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = creator {
		local_var_form =
			local_var_form.text("creator", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = keywords {
		local_var_form =
			local_var_form.text("keywords", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = modification_date {
		local_var_form = local_var_form
			.text("modificationDate", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = producer {
		local_var_form =
			local_var_form.text("producer", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = subject {
		local_var_form =
			local_var_form.text("subject", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = title {
		local_var_form =
			local_var_form.text("title", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = trapped {
		local_var_form =
			local_var_form.text("trapped", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = all_request_params {
		local_var_form = local_var_form.text(
			"allRequestParams",
			to_value(local_var_param_value)
				.expect("couldnt turn hashmap to json string")
				.to_string(),
		);
	}
	local_var_req_builder = local_var_req_builder.multipart(local_var_form);

	let local_var_req = local_var_req_builder.build()?;
	let local_var_resp = local_var_client.execute(local_var_req).await?;

	let local_var_status = local_var_resp.status();
	let local_var_content = local_var_resp.text().await?;

	if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
		serde_json::from_str(&local_var_content).map_err(Error::from)
	} else {
		let local_var_entity: Option<MetadataError> =
			serde_json::from_str(&local_var_content).ok();
		let local_var_error = ResponseContent {
			status: local_var_status,
			content: local_var_content,
			entity: local_var_entity,
		};
		Err(Error::ResponseError(local_var_error))
	}
}

/// This endpoint accepts a PDF file and optimizes it based on the provided parameters. Input:PDF Output:PDF Type:SISO
pub async fn optimize_pdf(
	configuration: &configuration::Configuration,
	file_input: Option<std::path::PathBuf>,
	optimize_level: Option<i32>,
	expected_output_size: Option<&str>,
) -> Result<Vec<String>, Error<OptimizePdfError>> {
	let local_var_configuration = configuration;

	let local_var_client = &local_var_configuration.client;

	let local_var_uri_str = format!(
		"{}/api/v1/misc/compress-pdf",
		local_var_configuration.base_path
	);
	let mut local_var_req_builder =
		local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

	if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
		local_var_req_builder = local_var_req_builder
			.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
	}
	let mut local_var_form = reqwest::multipart::Form::new();
	// TODO: support file upload for 'fileInput' parameter
	if let Some(local_var_param_value) = optimize_level {
		local_var_form =
			local_var_form.text("optimizeLevel", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = expected_output_size {
		local_var_form = local_var_form
			.text("expectedOutputSize", local_var_param_value.to_string());
	}
	local_var_req_builder = local_var_req_builder.multipart(local_var_form);

	let local_var_req = local_var_req_builder.build()?;
	let local_var_resp = local_var_client.execute(local_var_req).await?;

	let local_var_status = local_var_resp.status();
	let local_var_content = local_var_resp.text().await?;

	if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
		serde_json::from_str(&local_var_content).map_err(Error::from)
	} else {
		let local_var_entity: Option<OptimizePdfError> =
			serde_json::from_str(&local_var_content).ok();
		let local_var_error = ResponseContent {
			status: local_var_status,
			content: local_var_content,
			entity: local_var_entity,
		};
		Err(Error::ResponseError(local_var_error))
	}
}

/// This endpoint overlays an image onto a PDF file at the specified coordinates. The image can be overlaid on every page of the PDF if specified.  Input:PDF/IMAGE Output:PDF Type:SISO
pub async fn overlay_image(
	configuration: &configuration::Configuration,
	file_input: Option<std::path::PathBuf>,
	image_file: Option<std::path::PathBuf>,
	x: Option<f32>,
	y: Option<f32>,
	every_page: Option<bool>,
) -> Result<Vec<String>, Error<OverlayImageError>> {
	let local_var_configuration = configuration;

	let local_var_client = &local_var_configuration.client;

	let local_var_uri_str = format!(
		"{}/api/v1/misc/add-image",
		local_var_configuration.base_path
	);
	let mut local_var_req_builder =
		local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

	if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
		local_var_req_builder = local_var_req_builder
			.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
	}
	let mut local_var_form = reqwest::multipart::Form::new();
	// TODO: support file upload for 'fileInput' parameter
	// TODO: support file upload for 'imageFile' parameter
	if let Some(local_var_param_value) = x {
		local_var_form = local_var_form.text("x", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = y {
		local_var_form = local_var_form.text("y", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = every_page {
		local_var_form =
			local_var_form.text("everyPage", local_var_param_value.to_string());
	}
	local_var_req_builder = local_var_req_builder.multipart(local_var_form);

	let local_var_req = local_var_req_builder.build()?;
	let local_var_resp = local_var_client.execute(local_var_req).await?;

	let local_var_status = local_var_resp.status();
	let local_var_content = local_var_resp.text().await?;

	if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
		serde_json::from_str(&local_var_content).map_err(Error::from)
	} else {
		let local_var_entity: Option<OverlayImageError> =
			serde_json::from_str(&local_var_content).ok();
		let local_var_error = ResponseContent {
			status: local_var_status,
			content: local_var_content,
			entity: local_var_entity,
		};
		Err(Error::ResponseError(local_var_error))
	}
}

/// This endpoint processes a PDF file using OCR (Optical Character Recognition). Users can specify languages, sidecar, deskew, clean, cleanFinal, ocrType, ocrRenderType, and removeImagesAfter options. Input:PDF Output:PDF Type:SI-Conditional
pub async fn process_pdf_with_ocr(
	configuration: &configuration::Configuration,
	file_input: Option<std::path::PathBuf>,
	languages: Option<Vec<String>>,
	sidecar: Option<bool>,
	deskew: Option<bool>,
	clean: Option<bool>,
	clean_final: Option<bool>,
	ocr_type: Option<&str>,
	ocr_render_type: Option<&str>,
	remove_images_after: Option<bool>,
) -> Result<Vec<String>, Error<ProcessPdfWithOcrError>> {
	let local_var_configuration = configuration;

	let local_var_client = &local_var_configuration.client;

	let local_var_uri_str =
		format!("{}/api/v1/misc/ocr-pdf", local_var_configuration.base_path);
	let mut local_var_req_builder =
		local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

	if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
		local_var_req_builder = local_var_req_builder
			.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
	}
	let mut local_var_form = reqwest::multipart::Form::new();
	// TODO: support file upload for 'fileInput' parameter
	if let Some(local_var_param_value) = languages {
		local_var_form = local_var_form.text(
			"languages",
			local_var_param_value
				.into_iter()
				.map(|p| p.to_string())
				.collect::<Vec<String>>()
				.join(",")
				.to_string(),
		);
	}
	if let Some(local_var_param_value) = sidecar {
		local_var_form =
			local_var_form.text("sidecar", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = deskew {
		local_var_form =
			local_var_form.text("deskew", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = clean {
		local_var_form =
			local_var_form.text("clean", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = clean_final {
		local_var_form =
			local_var_form.text("cleanFinal", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = ocr_type {
		local_var_form =
			local_var_form.text("ocrType", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = ocr_render_type {
		local_var_form =
			local_var_form.text("ocrRenderType", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = remove_images_after {
		local_var_form = local_var_form
			.text("removeImagesAfter", local_var_param_value.to_string());
	}
	local_var_req_builder = local_var_req_builder.multipart(local_var_form);

	let local_var_req = local_var_req_builder.build()?;
	let local_var_resp = local_var_client.execute(local_var_req).await?;

	let local_var_status = local_var_resp.status();
	let local_var_content = local_var_resp.text().await?;

	if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
		serde_json::from_str(&local_var_content).map_err(Error::from)
	} else {
		let local_var_entity: Option<ProcessPdfWithOcrError> =
			serde_json::from_str(&local_var_content).ok();
		let local_var_error = ResponseContent {
			status: local_var_status,
			content: local_var_content,
			entity: local_var_entity,
		};
		Err(Error::ResponseError(local_var_error))
	}
}

/// This endpoint removes blank pages from a given PDF file. Users can specify the threshold and white percentage to tune the detection of blank pages. Input:PDF Output:PDF Type:SISO
pub async fn remove_blank_pages(
	configuration: &configuration::Configuration,
	file_input: Option<std::path::PathBuf>,
	threshold: Option<i32>,
	white_percent: Option<f32>,
) -> Result<Vec<String>, Error<RemoveBlankPagesError>> {
	let local_var_configuration = configuration;

	let local_var_client = &local_var_configuration.client;

	let local_var_uri_str = format!(
		"{}/api/v1/misc/remove-blanks",
		local_var_configuration.base_path
	);
	let mut local_var_req_builder =
		local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

	if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
		local_var_req_builder = local_var_req_builder
			.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
	}
	let mut local_var_form = reqwest::multipart::Form::new();
	// TODO: support file upload for 'fileInput' parameter
	if let Some(local_var_param_value) = threshold {
		local_var_form =
			local_var_form.text("threshold", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = white_percent {
		local_var_form =
			local_var_form.text("whitePercent", local_var_param_value.to_string());
	}
	local_var_req_builder = local_var_req_builder.multipart(local_var_form);

	let local_var_req = local_var_req_builder.build()?;
	let local_var_resp = local_var_client.execute(local_var_req).await?;

	let local_var_status = local_var_resp.status();
	let local_var_content = local_var_resp.text().await?;

	if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
		serde_json::from_str(&local_var_content).map_err(Error::from)
	} else {
		let local_var_entity: Option<RemoveBlankPagesError> =
			serde_json::from_str(&local_var_content).ok();
		let local_var_error = ResponseContent {
			status: local_var_status,
			content: local_var_content,
			entity: local_var_entity,
		};
		Err(Error::ResponseError(local_var_error))
	}
}

/// This endpoint repairs a given PDF file by running Ghostscript command. The PDF is first saved to a temporary location, repaired, read back, and then returned as a response. Input:PDF Output:PDF Type:SISO
pub async fn repair_pdf(
	configuration: &configuration::Configuration,
	file_input: Option<std::path::PathBuf>,
) -> Result<Vec<String>, Error<RepairPdfError>> {
	let local_var_configuration = configuration;

	let local_var_client = &local_var_configuration.client;

	let local_var_uri_str =
		format!("{}/api/v1/misc/repair", local_var_configuration.base_path);
	let mut local_var_req_builder =
		local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

	if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
		local_var_req_builder = local_var_req_builder
			.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
	}
	let mut local_var_form = reqwest::multipart::Form::new();
	// TODO: support file upload for 'fileInput' parameter
	local_var_req_builder = local_var_req_builder.multipart(local_var_form);

	let local_var_req = local_var_req_builder.build()?;
	let local_var_resp = local_var_client.execute(local_var_req).await?;

	let local_var_status = local_var_resp.status();
	let local_var_content = local_var_resp.text().await?;

	if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
		serde_json::from_str(&local_var_content).map_err(Error::from)
	} else {
		let local_var_entity: Option<RepairPdfError> =
			serde_json::from_str(&local_var_content).ok();
		let local_var_error = ResponseContent {
			status: local_var_status,
			content: local_var_content,
			entity: local_var_entity,
		};
		Err(Error::ResponseError(local_var_error))
	}
}

/// This endpoint accepts a PDF file and option of invert all colors or replace text and background colors. Input:PDF Output:PDF Type:SISO
pub async fn replace_and_invert_color(
	configuration: &configuration::Configuration,
	file_input: Option<std::path::PathBuf>,
	replace_and_invert_option: Option<&str>,
	high_contrast_color_combination: Option<&str>,
	back_ground_color: Option<&str>,
	text_color: Option<&str>,
) -> Result<std::path::PathBuf, Error<ReplaceAndInvertColorError>> {
	let local_var_configuration = configuration;

	let local_var_client = &local_var_configuration.client;

	let local_var_uri_str = format!(
		"{}/api/v1/misc/replace-invert-pdf",
		local_var_configuration.base_path
	);
	let mut local_var_req_builder =
		local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

	if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
		local_var_req_builder = local_var_req_builder
			.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
	}
	let mut local_var_form = reqwest::multipart::Form::new();
	// TODO: support file upload for 'fileInput' parameter
	if let Some(local_var_param_value) = replace_and_invert_option {
		local_var_form = local_var_form
			.text("replaceAndInvertOption", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = high_contrast_color_combination {
		local_var_form = local_var_form.text(
			"highContrastColorCombination",
			local_var_param_value.to_string(),
		);
	}
	if let Some(local_var_param_value) = back_ground_color {
		local_var_form = local_var_form
			.text("backGroundColor", local_var_param_value.to_string());
	}
	if let Some(local_var_param_value) = text_color {
		local_var_form =
			local_var_form.text("textColor", local_var_param_value.to_string());
	}
	local_var_req_builder = local_var_req_builder.multipart(local_var_form);

	let local_var_req = local_var_req_builder.build()?;
	let local_var_resp = local_var_client.execute(local_var_req).await?;

	let local_var_status = local_var_resp.status();
	let local_var_content = local_var_resp.text().await?;

	if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
		serde_json::from_str(&local_var_content).map_err(Error::from)
	} else {
		let local_var_entity: Option<ReplaceAndInvertColorError> =
			serde_json::from_str(&local_var_content).ok();
		let local_var_error = ResponseContent {
			status: local_var_status,
			content: local_var_content,
			entity: local_var_entity,
		};
		Err(Error::ResponseError(local_var_error))
	}
}
