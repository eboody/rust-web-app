/*
 * Stirling PDF API
 *
 * API documentation for all Server-Side processing. Please note some functionality might be UI only and missing from here.
 *
 * The version of the OpenAPI document: 0.34.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, Error};
use crate::{apis::ResponseContent, models};
use async_trait::async_trait;
use reqwest;
use serde::{Deserialize, Serialize};
use std::sync::Arc;

#[async_trait]
pub trait MiscApi: Send + Sync {
	async fn add_page_numbers<
		'file_input,
		'page_numbers,
		'custom_margin,
		'font_size,
		'font_type,
		'position,
		'starting_number,
		'pages_to_number,
		'custom_text,
	>(
		&self,
		file_input: Option<std::path::PathBuf>,
		page_numbers: Option<&'page_numbers str>,
		custom_margin: Option<&'custom_margin str>,
		font_size: Option<f32>,
		font_type: Option<&'font_type str>,
		position: Option<i32>,
		starting_number: Option<i32>,
		pages_to_number: Option<&'pages_to_number str>,
		custom_text: Option<&'custom_text str>,
	) -> Result<Vec<String>, Error<AddPageNumbersError>>;
	async fn add_stamp<
		'stamp_type,
		'file_input,
		'page_numbers,
		'stamp_text,
		'stamp_image,
		'alphabet,
		'font_size,
		'rotation,
		'opacity,
		'position,
		'override_x,
		'override_y,
		'custom_margin,
		'custom_color,
	>(
		&self,
		stamp_type: &'stamp_type str,
		file_input: Option<std::path::PathBuf>,
		page_numbers: Option<&'page_numbers str>,
		stamp_text: Option<&'stamp_text str>,
		stamp_image: Option<std::path::PathBuf>,
		alphabet: Option<&'alphabet str>,
		font_size: Option<f32>,
		rotation: Option<f32>,
		opacity: Option<f32>,
		position: Option<i32>,
		override_x: Option<f32>,
		override_y: Option<f32>,
		custom_margin: Option<&'custom_margin str>,
		custom_color: Option<&'custom_color str>,
	) -> Result<Vec<String>, Error<AddStampError>>;
	async fn auto_split_pdf<'file_input, 'duplex_mode>(
		&self,
		file_input: Option<std::path::PathBuf>,
		duplex_mode: Option<bool>,
	) -> Result<Vec<String>, Error<AutoSplitPdfError>>;
	async fn extract_header<'file_input>(
		&self,
		file_input: Option<std::path::PathBuf>,
	) -> Result<Vec<String>, Error<ExtractHeaderError>>;
	async fn extract_header1<'file_input, 'use_first_text_as_fallback>(
		&self,
		file_input: Option<std::path::PathBuf>,
		use_first_text_as_fallback: Option<bool>,
	) -> Result<Vec<String>, Error<ExtractHeader1Error>>;
	async fn extract_image_scans<
		'file_input,
		'angle_threshold,
		'tolerance,
		'min_area,
		'min_contour_area,
		'border_size,
	>(
		&self,
		file_input: std::path::PathBuf,
		angle_threshold: Option<i32>,
		tolerance: Option<i32>,
		min_area: Option<i32>,
		min_contour_area: Option<i32>,
		border_size: Option<i32>,
	) -> Result<Vec<String>, Error<ExtractImageScansError>>;
	async fn extract_images<'file_input, 'format, 'allow_duplicates>(
		&self,
		file_input: Option<std::path::PathBuf>,
		format: Option<&'format str>,
		allow_duplicates: Option<bool>,
	) -> Result<Vec<String>, Error<ExtractImagesError>>;
	async fn flatten<'file_input, 'flatten_only_forms>(
		&self,
		file_input: Option<std::path::PathBuf>,
		flatten_only_forms: Option<bool>,
	) -> Result<Vec<String>, Error<FlattenError>>;
	async fn metadata<
		'file_input,
		'delete_all,
		'author,
		'creation_date,
		'creator,
		'keywords,
		'modification_date,
		'producer,
		'subject,
		'title,
		'trapped,
		'all_request_params,
	>(
		&self,
		file_input: Option<std::path::PathBuf>,
		delete_all: Option<bool>,
		author: Option<&'author str>,
		creation_date: Option<&'creation_date str>,
		creator: Option<&'creator str>,
		keywords: Option<&'keywords str>,
		modification_date: Option<&'modification_date str>,
		producer: Option<&'producer str>,
		subject: Option<&'subject str>,
		title: Option<&'title str>,
		trapped: Option<&'trapped str>,
		all_request_params: Option<std::collections::HashMap<String, String>>,
	) -> Result<Vec<String>, Error<MetadataError>>;
	async fn optimize_pdf<'file_input, 'optimize_level, 'expected_output_size>(
		&self,
		file_input: Option<std::path::PathBuf>,
		optimize_level: Option<i32>,
		expected_output_size: Option<&'expected_output_size str>,
	) -> Result<Vec<String>, Error<OptimizePdfError>>;
	async fn overlay_image<'file_input, 'image_file, 'x, 'y, 'every_page>(
		&self,
		file_input: Option<std::path::PathBuf>,
		image_file: Option<std::path::PathBuf>,
		x: Option<f32>,
		y: Option<f32>,
		every_page: Option<bool>,
	) -> Result<Vec<String>, Error<OverlayImageError>>;
	async fn process_pdf_with_ocr<
		'file_input,
		'languages,
		'sidecar,
		'deskew,
		'clean,
		'clean_final,
		'ocr_type,
		'ocr_render_type,
		'remove_images_after,
	>(
		&self,
		file_input: Option<std::path::PathBuf>,
		languages: Option<Vec<String>>,
		sidecar: Option<bool>,
		deskew: Option<bool>,
		clean: Option<bool>,
		clean_final: Option<bool>,
		ocr_type: Option<&'ocr_type str>,
		ocr_render_type: Option<&'ocr_render_type str>,
		remove_images_after: Option<bool>,
	) -> Result<Vec<String>, Error<ProcessPdfWithOcrError>>;
	async fn remove_blank_pages<'file_input, 'threshold, 'white_percent>(
		&self,
		file_input: Option<std::path::PathBuf>,
		threshold: Option<i32>,
		white_percent: Option<f32>,
	) -> Result<Vec<String>, Error<RemoveBlankPagesError>>;
	async fn repair_pdf<'file_input>(
		&self,
		file_input: Option<std::path::PathBuf>,
	) -> Result<Vec<String>, Error<RepairPdfError>>;
	async fn replace_and_invert_color<
		'file_input,
		'replace_and_invert_option,
		'high_contrast_color_combination,
		'back_ground_color,
		'text_color,
	>(
		&self,
		file_input: Option<std::path::PathBuf>,
		replace_and_invert_option: Option<&'replace_and_invert_option str>,
		high_contrast_color_combination: Option<
			&'high_contrast_color_combination str,
		>,
		back_ground_color: Option<&'back_ground_color str>,
		text_color: Option<&'text_color str>,
	) -> Result<std::path::PathBuf, Error<ReplaceAndInvertColorError>>;
}

pub struct MiscApiClient {
	configuration: Arc<configuration::Configuration>,
}

impl MiscApiClient {
	pub fn new(configuration: Arc<configuration::Configuration>) -> Self {
		Self { configuration }
	}
}

#[async_trait]
impl MiscApi for MiscApiClient {
	/// This operation takes an input PDF file and adds page numbers to it. Input:PDF Output:PDF Type:SISO
	async fn add_page_numbers<
		'file_input,
		'page_numbers,
		'custom_margin,
		'font_size,
		'font_type,
		'position,
		'starting_number,
		'pages_to_number,
		'custom_text,
	>(
		&self,
		file_input: Option<std::path::PathBuf>,
		page_numbers: Option<&'page_numbers str>,
		custom_margin: Option<&'custom_margin str>,
		font_size: Option<f32>,
		font_type: Option<&'font_type str>,
		position: Option<i32>,
		starting_number: Option<i32>,
		pages_to_number: Option<&'pages_to_number str>,
		custom_text: Option<&'custom_text str>,
	) -> Result<Vec<String>, Error<AddPageNumbersError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/api/v1/misc/add-page-numbers",
			local_var_configuration.base_path
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		let mut local_var_form = reqwest::multipart::Form::new();
		// TODO: support file upload for 'fileInput' parameter
		if let Some(local_var_param_value) = page_numbers {
			local_var_form = local_var_form
				.text("pageNumbers", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = custom_margin {
			local_var_form = local_var_form
				.text("customMargin", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = font_size {
			local_var_form =
				local_var_form.text("fontSize", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = font_type {
			local_var_form =
				local_var_form.text("fontType", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = position {
			local_var_form =
				local_var_form.text("position", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = starting_number {
			local_var_form = local_var_form
				.text("startingNumber", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = pages_to_number {
			local_var_form = local_var_form
				.text("pagesToNumber", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = custom_text {
			local_var_form =
				local_var_form.text("customText", local_var_param_value.to_string());
		}
		local_var_req_builder = local_var_req_builder.multipart(local_var_form);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<AddPageNumbersError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// This endpoint adds a stamp to a given PDF file. Users can specify the stamp type (text or image), rotation, opacity, width spacer, and height spacer. Input:PDF Output:PDF Type:SISO
	async fn add_stamp<
		'stamp_type,
		'file_input,
		'page_numbers,
		'stamp_text,
		'stamp_image,
		'alphabet,
		'font_size,
		'rotation,
		'opacity,
		'position,
		'override_x,
		'override_y,
		'custom_margin,
		'custom_color,
	>(
		&self,
		stamp_type: &'stamp_type str,
		file_input: Option<std::path::PathBuf>,
		page_numbers: Option<&'page_numbers str>,
		stamp_text: Option<&'stamp_text str>,
		stamp_image: Option<std::path::PathBuf>,
		alphabet: Option<&'alphabet str>,
		font_size: Option<f32>,
		rotation: Option<f32>,
		opacity: Option<f32>,
		position: Option<i32>,
		override_x: Option<f32>,
		override_y: Option<f32>,
		custom_margin: Option<&'custom_margin str>,
		custom_color: Option<&'custom_color str>,
	) -> Result<Vec<String>, Error<AddStampError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/api/v1/misc/add-stamp",
			local_var_configuration.base_path
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		let mut local_var_form = reqwest::multipart::Form::new();
		// TODO: support file upload for 'fileInput' parameter
		if let Some(local_var_param_value) = page_numbers {
			local_var_form = local_var_form
				.text("pageNumbers", local_var_param_value.to_string());
		}
		local_var_form = local_var_form.text("stampType", stamp_type.to_string());
		if let Some(local_var_param_value) = stamp_text {
			local_var_form =
				local_var_form.text("stampText", local_var_param_value.to_string());
		}
		// TODO: support file upload for 'stampImage' parameter
		if let Some(local_var_param_value) = alphabet {
			local_var_form =
				local_var_form.text("alphabet", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = font_size {
			local_var_form =
				local_var_form.text("fontSize", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = rotation {
			local_var_form =
				local_var_form.text("rotation", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = opacity {
			local_var_form =
				local_var_form.text("opacity", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = position {
			local_var_form =
				local_var_form.text("position", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = override_x {
			local_var_form =
				local_var_form.text("overrideX", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = override_y {
			local_var_form =
				local_var_form.text("overrideY", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = custom_margin {
			local_var_form = local_var_form
				.text("customMargin", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = custom_color {
			local_var_form = local_var_form
				.text("customColor", local_var_param_value.to_string());
		}
		local_var_req_builder = local_var_req_builder.multipart(local_var_form);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<AddStampError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// This endpoint accepts a PDF file, scans each page for a specific QR code, and splits the document at the QR code boundaries. The output is a zip file containing each separate PDF document. Input:PDF Output:ZIP-PDF Type:SISO
	async fn auto_split_pdf<'file_input, 'duplex_mode>(
		&self,
		file_input: Option<std::path::PathBuf>,
		duplex_mode: Option<bool>,
	) -> Result<Vec<String>, Error<AutoSplitPdfError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/api/v1/misc/auto-split-pdf",
			local_var_configuration.base_path
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		let mut local_var_form = reqwest::multipart::Form::new();
		// TODO: support file upload for 'fileInput' parameter
		if let Some(local_var_param_value) = duplex_mode {
			local_var_form =
				local_var_form.text("duplexMode", local_var_param_value.to_string());
		}
		local_var_req_builder = local_var_req_builder.multipart(local_var_form);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<AutoSplitPdfError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// desc. Input:PDF Output:JS Type:SISO
	async fn extract_header<'file_input>(
		&self,
		file_input: Option<std::path::PathBuf>,
	) -> Result<Vec<String>, Error<ExtractHeaderError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/api/v1/misc/show-javascript",
			local_var_configuration.base_path
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		let local_var_form = reqwest::multipart::Form::new();
		// TODO: support file upload for 'fileInput' parameter
		local_var_req_builder = local_var_req_builder.multipart(local_var_form);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<ExtractHeaderError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// This endpoint accepts a PDF file and attempts to extract its title or header based on heuristics. Input:PDF Output:PDF Type:SISO
	async fn extract_header1<'file_input, 'use_first_text_as_fallback>(
		&self,
		file_input: Option<std::path::PathBuf>,
		use_first_text_as_fallback: Option<bool>,
	) -> Result<Vec<String>, Error<ExtractHeader1Error>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/api/v1/misc/auto-rename",
			local_var_configuration.base_path
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		let mut local_var_form = reqwest::multipart::Form::new();
		// TODO: support file upload for 'fileInput' parameter
		if let Some(local_var_param_value) = use_first_text_as_fallback {
			local_var_form = local_var_form
				.text("useFirstTextAsFallback", local_var_param_value.to_string());
		}
		local_var_req_builder = local_var_req_builder.multipart(local_var_form);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<ExtractHeader1Error> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// This endpoint extracts image scans from a given file based on certain parameters. Users can specify angle threshold, tolerance, minimum area, minimum contour area, and border size. Input:PDF Output:IMAGE/ZIP Type:SIMO
	async fn extract_image_scans<
		'file_input,
		'angle_threshold,
		'tolerance,
		'min_area,
		'min_contour_area,
		'border_size,
	>(
		&self,
		file_input: std::path::PathBuf,
		angle_threshold: Option<i32>,
		tolerance: Option<i32>,
		min_area: Option<i32>,
		min_contour_area: Option<i32>,
		border_size: Option<i32>,
	) -> Result<Vec<String>, Error<ExtractImageScansError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/api/v1/misc/extract-image-scans",
			local_var_configuration.base_path
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		let mut local_var_form = reqwest::multipart::Form::new();
		// TODO: support file upload for 'fileInput' parameter
		if let Some(local_var_param_value) = angle_threshold {
			local_var_form = local_var_form
				.text("angleThreshold", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = tolerance {
			local_var_form =
				local_var_form.text("tolerance", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = min_area {
			local_var_form =
				local_var_form.text("minArea", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = min_contour_area {
			local_var_form = local_var_form
				.text("minContourArea", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = border_size {
			local_var_form =
				local_var_form.text("borderSize", local_var_param_value.to_string());
		}
		local_var_req_builder = local_var_req_builder.multipart(local_var_form);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<ExtractImageScansError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// This endpoint extracts images from a given PDF file and returns them in a zip file. Users can specify the output image format. Input: PDF Output: IMAGE/ZIP Type: SIMO
	async fn extract_images<'file_input, 'format, 'allow_duplicates>(
		&self,
		file_input: Option<std::path::PathBuf>,
		format: Option<&'format str>,
		allow_duplicates: Option<bool>,
	) -> Result<Vec<String>, Error<ExtractImagesError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/api/v1/misc/extract-images",
			local_var_configuration.base_path
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		let mut local_var_form = reqwest::multipart::Form::new();
		// TODO: support file upload for 'fileInput' parameter
		if let Some(local_var_param_value) = format {
			local_var_form =
				local_var_form.text("format", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = allow_duplicates {
			local_var_form = local_var_form
				.text("allowDuplicates", local_var_param_value.to_string());
		}
		local_var_req_builder = local_var_req_builder.multipart(local_var_form);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<ExtractImagesError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Flattening just PDF form fields or converting each page to images to make text unselectable. Input: PDF, Output: PDF. Type: SISO
	async fn flatten<'file_input, 'flatten_only_forms>(
		&self,
		file_input: Option<std::path::PathBuf>,
		flatten_only_forms: Option<bool>,
	) -> Result<Vec<String>, Error<FlattenError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str =
			format!("{}/api/v1/misc/flatten", local_var_configuration.base_path);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		let mut local_var_form = reqwest::multipart::Form::new();
		// TODO: support file upload for 'fileInput' parameter
		if let Some(local_var_param_value) = flatten_only_forms {
			local_var_form = local_var_form
				.text("flattenOnlyForms", local_var_param_value.to_string());
		}
		local_var_req_builder = local_var_req_builder.multipart(local_var_form);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<FlattenError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// This endpoint allows you to update the metadata of a given PDF file. You can add, modify, or delete standard and custom metadata fields. Input:PDF Output:PDF Type:SISO
	async fn metadata<
		'file_input,
		'delete_all,
		'author,
		'creation_date,
		'creator,
		'keywords,
		'modification_date,
		'producer,
		'subject,
		'title,
		'trapped,
		'all_request_params,
	>(
		&self,
		file_input: Option<std::path::PathBuf>,
		delete_all: Option<bool>,
		author: Option<&'author str>,
		creation_date: Option<&'creation_date str>,
		creator: Option<&'creator str>,
		keywords: Option<&'keywords str>,
		modification_date: Option<&'modification_date str>,
		producer: Option<&'producer str>,
		subject: Option<&'subject str>,
		title: Option<&'title str>,
		trapped: Option<&'trapped str>,
		all_request_params: Option<std::collections::HashMap<String, String>>,
	) -> Result<Vec<String>, Error<MetadataError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/api/v1/misc/update-metadata",
			local_var_configuration.base_path
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		let mut local_var_form = reqwest::multipart::Form::new();
		// TODO: support file upload for 'fileInput' parameter
		if let Some(local_var_param_value) = delete_all {
			local_var_form =
				local_var_form.text("deleteAll", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = author {
			local_var_form =
				local_var_form.text("author", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = creation_date {
			local_var_form = local_var_form
				.text("creationDate", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = creator {
			local_var_form =
				local_var_form.text("creator", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = keywords {
			local_var_form =
				local_var_form.text("keywords", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = modification_date {
			local_var_form = local_var_form
				.text("modificationDate", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = producer {
			local_var_form =
				local_var_form.text("producer", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = subject {
			local_var_form =
				local_var_form.text("subject", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = title {
			local_var_form =
				local_var_form.text("title", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = trapped {
			local_var_form =
				local_var_form.text("trapped", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = all_request_params {
			local_var_form = local_var_form.text(
				"allRequestParams",
				serde_json::to_string(&local_var_param_value)
					.expect("impossible to fail"),
			);
		}
		local_var_req_builder = local_var_req_builder.multipart(local_var_form);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<MetadataError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// This endpoint accepts a PDF file and optimizes it based on the provided parameters. Input:PDF Output:PDF Type:SISO
	async fn optimize_pdf<'file_input, 'optimize_level, 'expected_output_size>(
		&self,
		file_input: Option<std::path::PathBuf>,
		optimize_level: Option<i32>,
		expected_output_size: Option<&'expected_output_size str>,
	) -> Result<Vec<String>, Error<OptimizePdfError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/api/v1/misc/compress-pdf",
			local_var_configuration.base_path
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		let mut local_var_form = reqwest::multipart::Form::new();
		// TODO: support file upload for 'fileInput' parameter
		if let Some(local_var_param_value) = optimize_level {
			local_var_form = local_var_form
				.text("optimizeLevel", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = expected_output_size {
			local_var_form = local_var_form
				.text("expectedOutputSize", local_var_param_value.to_string());
		}
		local_var_req_builder = local_var_req_builder.multipart(local_var_form);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<OptimizePdfError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// This endpoint overlays an image onto a PDF file at the specified coordinates. The image can be overlaid on every page of the PDF if specified.  Input:PDF/IMAGE Output:PDF Type:SISO
	async fn overlay_image<'file_input, 'image_file, 'x, 'y, 'every_page>(
		&self,
		file_input: Option<std::path::PathBuf>,
		image_file: Option<std::path::PathBuf>,
		x: Option<f32>,
		y: Option<f32>,
		every_page: Option<bool>,
	) -> Result<Vec<String>, Error<OverlayImageError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/api/v1/misc/add-image",
			local_var_configuration.base_path
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		let mut local_var_form = reqwest::multipart::Form::new();
		// TODO: support file upload for 'fileInput' parameter
		// TODO: support file upload for 'imageFile' parameter
		if let Some(local_var_param_value) = x {
			local_var_form =
				local_var_form.text("x", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = y {
			local_var_form =
				local_var_form.text("y", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = every_page {
			local_var_form =
				local_var_form.text("everyPage", local_var_param_value.to_string());
		}
		local_var_req_builder = local_var_req_builder.multipart(local_var_form);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<OverlayImageError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// This endpoint processes a PDF file using OCR (Optical Character Recognition). Users can specify languages, sidecar, deskew, clean, cleanFinal, ocrType, ocrRenderType, and removeImagesAfter options. Input:PDF Output:PDF Type:SI-Conditional
	async fn process_pdf_with_ocr<
		'file_input,
		'languages,
		'sidecar,
		'deskew,
		'clean,
		'clean_final,
		'ocr_type,
		'ocr_render_type,
		'remove_images_after,
	>(
		&self,
		file_input: Option<std::path::PathBuf>,
		languages: Option<Vec<String>>,
		sidecar: Option<bool>,
		deskew: Option<bool>,
		clean: Option<bool>,
		clean_final: Option<bool>,
		ocr_type: Option<&'ocr_type str>,
		ocr_render_type: Option<&'ocr_render_type str>,
		remove_images_after: Option<bool>,
	) -> Result<Vec<String>, Error<ProcessPdfWithOcrError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str =
			format!("{}/api/v1/misc/ocr-pdf", local_var_configuration.base_path);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		let mut local_var_form = reqwest::multipart::Form::new();
		// TODO: support file upload for 'fileInput' parameter
		if let Some(local_var_param_value) = languages {
			local_var_form = local_var_form.text(
				"languages",
				local_var_param_value
					.into_iter()
					.map(|p| p.to_string())
					.collect::<Vec<String>>()
					.join(",")
					.to_string(),
			);
		}
		if let Some(local_var_param_value) = sidecar {
			local_var_form =
				local_var_form.text("sidecar", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = deskew {
			local_var_form =
				local_var_form.text("deskew", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = clean {
			local_var_form =
				local_var_form.text("clean", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = clean_final {
			local_var_form =
				local_var_form.text("cleanFinal", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = ocr_type {
			local_var_form =
				local_var_form.text("ocrType", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = ocr_render_type {
			local_var_form = local_var_form
				.text("ocrRenderType", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = remove_images_after {
			local_var_form = local_var_form
				.text("removeImagesAfter", local_var_param_value.to_string());
		}
		local_var_req_builder = local_var_req_builder.multipart(local_var_form);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<ProcessPdfWithOcrError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// This endpoint removes blank pages from a given PDF file. Users can specify the threshold and white percentage to tune the detection of blank pages. Input:PDF Output:PDF Type:SISO
	async fn remove_blank_pages<'file_input, 'threshold, 'white_percent>(
		&self,
		file_input: Option<std::path::PathBuf>,
		threshold: Option<i32>,
		white_percent: Option<f32>,
	) -> Result<Vec<String>, Error<RemoveBlankPagesError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/api/v1/misc/remove-blanks",
			local_var_configuration.base_path
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		let mut local_var_form = reqwest::multipart::Form::new();
		// TODO: support file upload for 'fileInput' parameter
		if let Some(local_var_param_value) = threshold {
			local_var_form =
				local_var_form.text("threshold", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = white_percent {
			local_var_form = local_var_form
				.text("whitePercent", local_var_param_value.to_string());
		}
		local_var_req_builder = local_var_req_builder.multipart(local_var_form);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<RemoveBlankPagesError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// This endpoint repairs a given PDF file by running Ghostscript command. The PDF is first saved to a temporary location, repaired, read back, and then returned as a response. Input:PDF Output:PDF Type:SISO
	async fn repair_pdf<'file_input>(
		&self,
		file_input: Option<std::path::PathBuf>,
	) -> Result<Vec<String>, Error<RepairPdfError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str =
			format!("{}/api/v1/misc/repair", local_var_configuration.base_path);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		let local_var_form = reqwest::multipart::Form::new();
		// TODO: support file upload for 'fileInput' parameter
		local_var_req_builder = local_var_req_builder.multipart(local_var_form);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<RepairPdfError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// This endpoint accepts a PDF file and option of invert all colors or replace text and background colors. Input:PDF Output:PDF Type:SISO
	async fn replace_and_invert_color<
		'file_input,
		'replace_and_invert_option,
		'high_contrast_color_combination,
		'back_ground_color,
		'text_color,
	>(
		&self,
		file_input: Option<std::path::PathBuf>,
		replace_and_invert_option: Option<&'replace_and_invert_option str>,
		high_contrast_color_combination: Option<
			&'high_contrast_color_combination str,
		>,
		back_ground_color: Option<&'back_ground_color str>,
		text_color: Option<&'text_color str>,
	) -> Result<std::path::PathBuf, Error<ReplaceAndInvertColorError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/api/v1/misc/replace-invert-pdf",
			local_var_configuration.base_path
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		let mut local_var_form = reqwest::multipart::Form::new();
		// TODO: support file upload for 'fileInput' parameter
		if let Some(local_var_param_value) = replace_and_invert_option {
			local_var_form = local_var_form
				.text("replaceAndInvertOption", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = high_contrast_color_combination {
			local_var_form = local_var_form.text(
				"highContrastColorCombination",
				local_var_param_value.to_string(),
			);
		}
		if let Some(local_var_param_value) = back_ground_color {
			local_var_form = local_var_form
				.text("backGroundColor", local_var_param_value.to_string());
		}
		if let Some(local_var_param_value) = text_color {
			local_var_form =
				local_var_form.text("textColor", local_var_param_value.to_string());
		}
		local_var_req_builder = local_var_req_builder.multipart(local_var_form);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<ReplaceAndInvertColorError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}
}

/// struct for typed errors of method [`add_page_numbers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddPageNumbersError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`add_stamp`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddStampError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`auto_split_pdf`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AutoSplitPdfError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`extract_header`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExtractHeaderError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`extract_header1`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExtractHeader1Error {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`extract_image_scans`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExtractImageScansError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`extract_images`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExtractImagesError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`flatten`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FlattenError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`optimize_pdf`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OptimizePdfError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`overlay_image`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OverlayImageError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`process_pdf_with_ocr`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ProcessPdfWithOcrError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_blank_pages`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveBlankPagesError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`repair_pdf`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RepairPdfError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`replace_and_invert_color`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReplaceAndInvertColorError {
	UnknownValue(serde_json::Value),
}
