/*
 * AnythingLLM Developer API
 *
 * API endpoints that enable programmatic reading, writing, and updating of your AnythingLLM instance. UI supplied by Swagger.io.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, Error};
use crate::{apis::ResponseContent, models};
use async_trait::async_trait;
use reqwest;
use serde::{Deserialize, Serialize};
use std::sync::Arc;

#[async_trait]
pub trait WorkspacesApi: Send + Sync {
	async fn v1_workspace_new_post(
		&self,
	) -> Result<serde_json::Value, Error<V1WorkspaceNewPostError>>;
	async fn v1_workspace_slug_chat_post<'slug>(
		&self,
		slug: &'slug str,
	) -> Result<serde_json::Value, Error<V1WorkspaceSlugChatPostError>>;
	async fn v1_workspace_slug_chats_get<'slug, 'api_session_id, 'limit, 'order_by>(
		&self,
		slug: &'slug str,
		api_session_id: Option<&'api_session_id str>,
		limit: Option<i32>,
		order_by: Option<&'order_by str>,
	) -> Result<serde_json::Value, Error<V1WorkspaceSlugChatsGetError>>;
	async fn v1_workspace_slug_delete<'slug>(
		&self,
		slug: &'slug str,
	) -> Result<(), Error<V1WorkspaceSlugDeleteError>>;
	async fn v1_workspace_slug_get<'slug>(
		&self,
		slug: &'slug str,
	) -> Result<serde_json::Value, Error<V1WorkspaceSlugGetError>>;
	async fn v1_workspace_slug_stream_chat_post<'slug>(
		&self,
		slug: &'slug str,
	) -> Result<Vec<String>, Error<V1WorkspaceSlugStreamChatPostError>>;
	async fn v1_workspace_slug_update_embeddings_post<'slug>(
		&self,
		slug: &'slug str,
	) -> Result<serde_json::Value, Error<V1WorkspaceSlugUpdateEmbeddingsPostError>>;
	async fn v1_workspace_slug_update_pin_post<'slug>(
		&self,
		slug: &'slug str,
	) -> Result<serde_json::Value, Error<V1WorkspaceSlugUpdatePinPostError>>;
	async fn v1_workspace_slug_update_post<'slug>(
		&self,
		slug: &'slug str,
	) -> Result<serde_json::Value, Error<V1WorkspaceSlugUpdatePostError>>;
	async fn v1_workspaces_get(
		&self,
	) -> Result<serde_json::Value, Error<V1WorkspacesGetError>>;
}

pub struct WorkspacesApiClient {
	configuration: Arc<configuration::Configuration>,
}

impl WorkspacesApiClient {
	pub fn new(configuration: Arc<configuration::Configuration>) -> Self {
		Self { configuration }
	}
}

#[async_trait]
impl WorkspacesApi for WorkspacesApiClient {
	/// Create a new workspace
	async fn v1_workspace_new_post(
		&self,
	) -> Result<serde_json::Value, Error<V1WorkspaceNewPostError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str =
			format!("{}/v1/workspace/new", local_var_configuration.base_path);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<V1WorkspaceNewPostError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Execute a chat with a workspace
	async fn v1_workspace_slug_chat_post<'slug>(
		&self,
		slug: &'slug str,
	) -> Result<serde_json::Value, Error<V1WorkspaceSlugChatPostError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/v1/workspace/{slug}/chat",
			local_var_configuration.base_path,
			slug = crate::apis::urlencode(slug)
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<V1WorkspaceSlugChatPostError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Get a workspaces chats regardless of user by its unique slug.
	async fn v1_workspace_slug_chats_get<
		'slug,
		'api_session_id,
		'limit,
		'order_by,
	>(
		&self,
		slug: &'slug str,
		api_session_id: Option<&'api_session_id str>,
		limit: Option<i32>,
		order_by: Option<&'order_by str>,
	) -> Result<serde_json::Value, Error<V1WorkspaceSlugChatsGetError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/v1/workspace/{slug}/chats",
			local_var_configuration.base_path,
			slug = crate::apis::urlencode(slug)
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::GET, local_var_uri_str.as_str());

		if let Some(ref local_var_str) = api_session_id {
			local_var_req_builder = local_var_req_builder
				.query(&[("apiSessionId", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = limit {
			local_var_req_builder = local_var_req_builder
				.query(&[("limit", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = order_by {
			local_var_req_builder = local_var_req_builder
				.query(&[("orderBy", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<V1WorkspaceSlugChatsGetError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Deletes a workspace by its slug.
	async fn v1_workspace_slug_delete<'slug>(
		&self,
		slug: &'slug str,
	) -> Result<(), Error<V1WorkspaceSlugDeleteError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/v1/workspace/{slug}",
			local_var_configuration.base_path,
			slug = crate::apis::urlencode(slug)
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			Ok(())
		} else {
			let local_var_entity: Option<V1WorkspaceSlugDeleteError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Get a workspace by its unique slug.
	async fn v1_workspace_slug_get<'slug>(
		&self,
		slug: &'slug str,
	) -> Result<serde_json::Value, Error<V1WorkspaceSlugGetError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/v1/workspace/{slug}",
			local_var_configuration.base_path,
			slug = crate::apis::urlencode(slug)
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::GET, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<V1WorkspaceSlugGetError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Execute a streamable chat with a workspace
	async fn v1_workspace_slug_stream_chat_post<'slug>(
		&self,
		slug: &'slug str,
	) -> Result<Vec<String>, Error<V1WorkspaceSlugStreamChatPostError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/v1/workspace/{slug}/stream-chat",
			local_var_configuration.base_path,
			slug = crate::apis::urlencode(slug)
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<V1WorkspaceSlugStreamChatPostError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Add or remove documents from a workspace by its unique slug.
	async fn v1_workspace_slug_update_embeddings_post<'slug>(
		&self,
		slug: &'slug str,
	) -> Result<serde_json::Value, Error<V1WorkspaceSlugUpdateEmbeddingsPostError>>
	{
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/v1/workspace/{slug}/update-embeddings",
			local_var_configuration.base_path,
			slug = crate::apis::urlencode(slug)
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<V1WorkspaceSlugUpdateEmbeddingsPostError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Add or remove pin from a document in a workspace by its unique slug.
	async fn v1_workspace_slug_update_pin_post<'slug>(
		&self,
		slug: &'slug str,
	) -> Result<serde_json::Value, Error<V1WorkspaceSlugUpdatePinPostError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/v1/workspace/{slug}/update-pin",
			local_var_configuration.base_path,
			slug = crate::apis::urlencode(slug)
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<V1WorkspaceSlugUpdatePinPostError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Update workspace settings by its unique slug.
	async fn v1_workspace_slug_update_post<'slug>(
		&self,
		slug: &'slug str,
	) -> Result<serde_json::Value, Error<V1WorkspaceSlugUpdatePostError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/v1/workspace/{slug}/update",
			local_var_configuration.base_path,
			slug = crate::apis::urlencode(slug)
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<V1WorkspaceSlugUpdatePostError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// List all current workspaces
	async fn v1_workspaces_get(
		&self,
	) -> Result<serde_json::Value, Error<V1WorkspacesGetError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str =
			format!("{}/v1/workspaces", local_var_configuration.base_path);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::GET, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<V1WorkspacesGetError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}
}

/// struct for typed errors of method [`v1_workspace_new_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1WorkspaceNewPostError {
	Status403(models::InvalidApiKey),
	Status500(),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_workspace_slug_chat_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1WorkspaceSlugChatPostError {
	Status400(),
	Status403(models::InvalidApiKey),
	Status500(),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_workspace_slug_chats_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1WorkspaceSlugChatsGetError {
	Status400(),
	Status403(models::InvalidApiKey),
	Status500(),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_workspace_slug_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1WorkspaceSlugDeleteError {
	Status400(),
	Status403(models::InvalidApiKey),
	Status500(),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_workspace_slug_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1WorkspaceSlugGetError {
	Status403(models::InvalidApiKey),
	Status500(),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_workspace_slug_stream_chat_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1WorkspaceSlugStreamChatPostError {
	Status400(),
	Status403(models::InvalidApiKey),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_workspace_slug_update_embeddings_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1WorkspaceSlugUpdateEmbeddingsPostError {
	Status400(),
	Status403(models::InvalidApiKey),
	Status500(),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_workspace_slug_update_pin_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1WorkspaceSlugUpdatePinPostError {
	Status403(),
	Status404(),
	Status500(),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_workspace_slug_update_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1WorkspaceSlugUpdatePostError {
	Status400(),
	Status403(models::InvalidApiKey),
	Status500(),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`v1_workspaces_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum V1WorkspacesGetError {
	Status403(models::InvalidApiKey),
	Status500(),
	UnknownValue(serde_json::Value),
}
