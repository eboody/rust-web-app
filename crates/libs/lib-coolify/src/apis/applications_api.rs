/*
 * Coolify
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, Error};
use crate::{apis::ResponseContent, models};
use async_trait::async_trait;
use reqwest;
use serde::{Deserialize, Serialize};
use std::sync::Arc;

#[async_trait]
pub trait ApplicationsApi: Send + Sync {
	async fn create_dockercompose_application<
		'create_dockercompose_application_request,
	>(
		&self,
		create_dockercompose_application_request: models::CreateDockercomposeApplicationRequest,
	) -> Result<(), Error<CreateDockercomposeApplicationError>>;
	async fn create_dockerfile_application<'create_dockerfile_application_request>(
		&self,
		create_dockerfile_application_request: models::CreateDockerfileApplicationRequest,
	) -> Result<(), Error<CreateDockerfileApplicationError>>;
	async fn create_dockerimage_application<
		'create_dockerimage_application_request,
	>(
		&self,
		create_dockerimage_application_request: models::CreateDockerimageApplicationRequest,
	) -> Result<(), Error<CreateDockerimageApplicationError>>;
	async fn create_env_by_application_uuid<
		'uuid,
		'create_env_by_application_uuid_request,
	>(
		&self,
		uuid: &str,
		create_env_by_application_uuid_request: models::CreateEnvByApplicationUuidRequest,
	) -> Result<
		models::CreateEnvByApplicationUuid201Response,
		Error<CreateEnvByApplicationUuidError>,
	>;
	async fn create_private_deploy_key_application<
		'create_private_deploy_key_application_request,
	>(
		&self,
		create_private_deploy_key_application_request: models::CreatePrivateDeployKeyApplicationRequest,
	) -> Result<(), Error<CreatePrivateDeployKeyApplicationError>>;
	async fn create_private_github_app_application<
		'create_private_github_app_application_request,
	>(
		&self,
		create_private_github_app_application_request: models::CreatePrivateGithubAppApplicationRequest,
	) -> Result<(), Error<CreatePrivateGithubAppApplicationError>>;
	async fn create_public_application<'create_public_application_request>(
		&self,
		create_public_application_request: models::CreatePublicApplicationRequest,
	) -> Result<(), Error<CreatePublicApplicationError>>;
	async fn delete_application_by_uuid<
		'uuid,
		'delete_configurations,
		'delete_volumes,
		'docker_cleanup,
		'delete_connected_networks,
	>(
		&self,
		uuid: &str,
		delete_configurations: Option<bool>,
		delete_volumes: Option<bool>,
		docker_cleanup: Option<bool>,
		delete_connected_networks: Option<bool>,
	) -> Result<
		models::DeleteApplicationByUuid200Response,
		Error<DeleteApplicationByUuidError>,
	>;
	async fn delete_env_by_application_uuid<'uuid, 'env_uuid>(
		&self,
		uuid: &str,
		env_uuid: &str,
	) -> Result<
		models::DeleteEnvByApplicationUuid200Response,
		Error<DeleteEnvByApplicationUuidError>,
	>;
	async fn execute_command_application<
		'uuid,
		'execute_command_application_request,
	>(
		&self,
		uuid: &str,
		execute_command_application_request: models::ExecuteCommandApplicationRequest,
	) -> Result<
		models::ExecuteCommandApplication200Response,
		Error<ExecuteCommandApplicationError>,
	>;
	async fn get_application_by_uuid<'uuid>(
		&self,
		uuid: &str,
	) -> Result<models::Application, Error<GetApplicationByUuidError>>;
	async fn list_applications(
		&self,
	) -> Result<Vec<models::Application>, Error<ListApplicationsError>>;
	async fn list_envs_by_application_uuid<'uuid>(
		&self,
		uuid: &str,
	) -> Result<
		Vec<models::EnvironmentVariable>,
		Error<ListEnvsByApplicationUuidError>,
	>;
	async fn restart_application_by_uuid<'uuid>(
		&self,
		uuid: &str,
	) -> Result<
		models::RestartApplicationByUuid200Response,
		Error<RestartApplicationByUuidError>,
	>;
	async fn start_application_by_uuid<'uuid, 'force, 'instant_deploy>(
		&self,
		uuid: &str,
		force: Option<bool>,
		instant_deploy: Option<bool>,
	) -> Result<
		models::StartApplicationByUuid200Response,
		Error<StartApplicationByUuidError>,
	>;
	async fn stop_application_by_uuid<'uuid>(
		&self,
		uuid: &str,
	) -> Result<
		models::StopApplicationByUuid200Response,
		Error<StopApplicationByUuidError>,
	>;
	async fn update_application_by_uuid<'update_application_by_uuid_request>(
		&self,
		uuid: String,
		update_application_by_uuid_request: models::UpdateApplicationByUuidRequest,
	) -> Result<
		models::UpdateApplicationByUuid200Response,
		Error<UpdateApplicationByUuidError>,
	>;
	async fn update_env_by_application_uuid<
		'uuid,
		'update_env_by_application_uuid_request,
	>(
		&self,
		uuid: &str,
		update_env_by_application_uuid_request: models::UpdateEnvByApplicationUuidRequest,
	) -> Result<
		models::UpdateEnvByApplicationUuid201Response,
		Error<UpdateEnvByApplicationUuidError>,
	>;
	async fn update_envs_by_application_uuid<
		'uuid,
		'update_envs_by_application_uuid_request,
	>(
		&self,
		uuid: &str,
		update_envs_by_application_uuid_request: models::UpdateEnvsByApplicationUuidRequest,
	) -> Result<
		models::UpdateEnvsByApplicationUuid201Response,
		Error<UpdateEnvsByApplicationUuidError>,
	>;
}

pub struct ApplicationsApiClient {
	configuration: Arc<configuration::Configuration>,
}

impl ApplicationsApiClient {
	pub fn new(configuration: Arc<configuration::Configuration>) -> Self {
		Self { configuration }
	}
}

#[async_trait]
impl ApplicationsApi for ApplicationsApiClient {
	/// Create new application based on a docker-compose file.
	async fn create_dockercompose_application<
		'create_dockercompose_application_request,
	>(
		&self,
		create_dockercompose_application_request: models::CreateDockercomposeApplicationRequest,
	) -> Result<(), Error<CreateDockercomposeApplicationError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/applications/dockercompose",
			local_var_configuration.base_path
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};
		local_var_req_builder =
			local_var_req_builder.json(&create_dockercompose_application_request);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			Ok(())
		} else {
			let local_var_entity: Option<CreateDockercomposeApplicationError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Create new application based on a simple Dockerfile.
	async fn create_dockerfile_application<
		'create_dockerfile_application_request,
	>(
		&self,
		create_dockerfile_application_request: models::CreateDockerfileApplicationRequest,
	) -> Result<(), Error<CreateDockerfileApplicationError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/applications/dockerfile",
			local_var_configuration.base_path
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};
		local_var_req_builder =
			local_var_req_builder.json(&create_dockerfile_application_request);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			Ok(())
		} else {
			let local_var_entity: Option<CreateDockerfileApplicationError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Create new application based on a prebuilt docker image
	async fn create_dockerimage_application<
		'create_dockerimage_application_request,
	>(
		&self,
		create_dockerimage_application_request: models::CreateDockerimageApplicationRequest,
	) -> Result<(), Error<CreateDockerimageApplicationError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/applications/dockerimage",
			local_var_configuration.base_path
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};
		local_var_req_builder =
			local_var_req_builder.json(&create_dockerimage_application_request);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			Ok(())
		} else {
			let local_var_entity: Option<CreateDockerimageApplicationError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Create env by application UUID.
	async fn create_env_by_application_uuid<
		'uuid,
		'create_env_by_application_uuid_request,
	>(
		&self,
		uuid: &str,
		create_env_by_application_uuid_request: models::CreateEnvByApplicationUuidRequest,
	) -> Result<
		models::CreateEnvByApplicationUuid201Response,
		Error<CreateEnvByApplicationUuidError>,
	> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/applications/{uuid}/envs",
			local_var_configuration.base_path,
			uuid = crate::apis::urlencode(uuid)
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};
		local_var_req_builder =
			local_var_req_builder.json(&create_env_by_application_uuid_request);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<CreateEnvByApplicationUuidError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Create new application based on a private repository through a Deploy Key.
	async fn create_private_deploy_key_application<
		'create_private_deploy_key_application_request,
	>(
		&self,
		create_private_deploy_key_application_request: models::CreatePrivateDeployKeyApplicationRequest,
	) -> Result<(), Error<CreatePrivateDeployKeyApplicationError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/applications/private-deploy-key",
			local_var_configuration.base_path
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};
		local_var_req_builder = local_var_req_builder
			.json(&create_private_deploy_key_application_request);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			Ok(())
		} else {
			let local_var_entity: Option<CreatePrivateDeployKeyApplicationError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Create new application based on a private repository through a Github App.
	async fn create_private_github_app_application<
		'create_private_github_app_application_request,
	>(
		&self,
		create_private_github_app_application_request: models::CreatePrivateGithubAppApplicationRequest,
	) -> Result<(), Error<CreatePrivateGithubAppApplicationError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/applications/private-github-app",
			local_var_configuration.base_path
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};
		local_var_req_builder = local_var_req_builder
			.json(&create_private_github_app_application_request);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			Ok(())
		} else {
			let local_var_entity: Option<CreatePrivateGithubAppApplicationError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Create new application based on a public git repository.
	async fn create_public_application<'create_public_application_request>(
		&self,
		create_public_application_request: models::CreatePublicApplicationRequest,
	) -> Result<(), Error<CreatePublicApplicationError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str =
			format!("{}/applications/public", local_var_configuration.base_path);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};
		local_var_req_builder =
			local_var_req_builder.json(&create_public_application_request);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			Ok(())
		} else {
			let local_var_entity: Option<CreatePublicApplicationError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Delete application by UUID.
	async fn delete_application_by_uuid<
		'uuid,
		'delete_configurations,
		'delete_volumes,
		'docker_cleanup,
		'delete_connected_networks,
	>(
		&self,
		uuid: &str,
		delete_configurations: Option<bool>,
		delete_volumes: Option<bool>,
		docker_cleanup: Option<bool>,
		delete_connected_networks: Option<bool>,
	) -> Result<
		models::DeleteApplicationByUuid200Response,
		Error<DeleteApplicationByUuidError>,
	> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/applications/{uuid}",
			local_var_configuration.base_path,
			uuid = crate::apis::urlencode(uuid)
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

		if let Some(ref local_var_str) = delete_configurations {
			local_var_req_builder = local_var_req_builder
				.query(&[("delete_configurations", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = delete_volumes {
			local_var_req_builder = local_var_req_builder
				.query(&[("delete_volumes", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = docker_cleanup {
			local_var_req_builder = local_var_req_builder
				.query(&[("docker_cleanup", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = delete_connected_networks {
			local_var_req_builder = local_var_req_builder
				.query(&[("delete_connected_networks", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<DeleteApplicationByUuidError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Delete env by UUID.
	async fn delete_env_by_application_uuid<'uuid, 'env_uuid>(
		&self,
		uuid: &str,
		env_uuid: &str,
	) -> Result<
		models::DeleteEnvByApplicationUuid200Response,
		Error<DeleteEnvByApplicationUuidError>,
	> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/applications/{uuid}/envs/{env_uuid}",
			local_var_configuration.base_path,
			uuid = crate::apis::urlencode(uuid),
			env_uuid = crate::apis::urlencode(env_uuid)
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<DeleteEnvByApplicationUuidError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Execute a command on the application's current container.
	async fn execute_command_application<
		'uuid,
		'execute_command_application_request,
	>(
		&self,
		uuid: &str,
		execute_command_application_request: models::ExecuteCommandApplicationRequest,
	) -> Result<
		models::ExecuteCommandApplication200Response,
		Error<ExecuteCommandApplicationError>,
	> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/applications/{uuid}/execute",
			local_var_configuration.base_path,
			uuid = crate::apis::urlencode(uuid)
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};
		local_var_req_builder =
			local_var_req_builder.json(&execute_command_application_request);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<ExecuteCommandApplicationError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Get application by UUID.
	async fn get_application_by_uuid<'uuid>(
		&self,
		uuid: &str,
	) -> Result<models::Application, Error<GetApplicationByUuidError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/applications/{uuid}",
			local_var_configuration.base_path,
			uuid = crate::apis::urlencode(uuid)
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::GET, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<GetApplicationByUuidError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// List all applications.
	async fn list_applications(
		&self,
	) -> Result<Vec<models::Application>, Error<ListApplicationsError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str =
			format!("{}/applications", local_var_configuration.base_path);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::GET, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<ListApplicationsError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// List all envs by application UUID.
	async fn list_envs_by_application_uuid<'uuid>(
		&self,
		uuid: &str,
	) -> Result<
		Vec<models::EnvironmentVariable>,
		Error<ListEnvsByApplicationUuidError>,
	> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/applications/{uuid}/envs",
			local_var_configuration.base_path,
			uuid = crate::apis::urlencode(uuid)
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::GET, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<ListEnvsByApplicationUuidError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Restart application. `Post` request is also accepted.
	async fn restart_application_by_uuid<'uuid>(
		&self,
		uuid: &str,
	) -> Result<
		models::RestartApplicationByUuid200Response,
		Error<RestartApplicationByUuidError>,
	> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/applications/{uuid}/restart",
			local_var_configuration.base_path,
			uuid = crate::apis::urlencode(uuid)
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::GET, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<RestartApplicationByUuidError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Start application. `Post` request is also accepted.
	async fn start_application_by_uuid<'uuid, 'force, 'instant_deploy>(
		&self,
		uuid: &str,
		force: Option<bool>,
		instant_deploy: Option<bool>,
	) -> Result<
		models::StartApplicationByUuid200Response,
		Error<StartApplicationByUuidError>,
	> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/applications/{uuid}/start",
			local_var_configuration.base_path,
			uuid = crate::apis::urlencode(uuid)
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::GET, local_var_uri_str.as_str());

		if let Some(ref local_var_str) = force {
			local_var_req_builder = local_var_req_builder
				.query(&[("force", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = instant_deploy {
			local_var_req_builder = local_var_req_builder
				.query(&[("instant_deploy", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<StartApplicationByUuidError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Stop application. `Post` request is also accepted.
	async fn stop_application_by_uuid<'uuid>(
		&self,
		uuid: &str,
	) -> Result<
		models::StopApplicationByUuid200Response,
		Error<StopApplicationByUuidError>,
	> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/applications/{uuid}/stop",
			local_var_configuration.base_path,
			uuid = crate::apis::urlencode(uuid)
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::GET, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<StopApplicationByUuidError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Update application by UUID.
	async fn update_application_by_uuid<'update_application_by_uuid_request>(
		&self,
		uuid: String,
		update_application_by_uuid_request: models::UpdateApplicationByUuidRequest,
	) -> Result<
		models::UpdateApplicationByUuid200Response,
		Error<UpdateApplicationByUuidError>,
	> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str =
			format!("{}/applications/{uuid}", local_var_configuration.base_path);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};
		local_var_req_builder =
			local_var_req_builder.json(&update_application_by_uuid_request);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<UpdateApplicationByUuidError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Update env by application UUID.
	async fn update_env_by_application_uuid<
		'uuid,
		'update_env_by_application_uuid_request,
	>(
		&self,
		uuid: &str,
		update_env_by_application_uuid_request: models::UpdateEnvByApplicationUuidRequest,
	) -> Result<
		models::UpdateEnvByApplicationUuid201Response,
		Error<UpdateEnvByApplicationUuidError>,
	> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/applications/{uuid}/envs",
			local_var_configuration.base_path,
			uuid = crate::apis::urlencode(uuid)
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};
		local_var_req_builder =
			local_var_req_builder.json(&update_env_by_application_uuid_request);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<UpdateEnvByApplicationUuidError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Update multiple envs by application UUID.
	async fn update_envs_by_application_uuid<
		'uuid,
		'update_envs_by_application_uuid_request,
	>(
		&self,
		uuid: &str,
		update_envs_by_application_uuid_request: models::UpdateEnvsByApplicationUuidRequest,
	) -> Result<
		models::UpdateEnvsByApplicationUuid201Response,
		Error<UpdateEnvsByApplicationUuidError>,
	> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/applications/{uuid}/envs/bulk",
			local_var_configuration.base_path,
			uuid = crate::apis::urlencode(uuid)
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};
		local_var_req_builder =
			local_var_req_builder.json(&update_envs_by_application_uuid_request);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<UpdateEnvsByApplicationUuidError> =
				serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}
}

/// struct for typed errors of method [`create_dockercompose_application`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDockercomposeApplicationError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_dockerfile_application`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDockerfileApplicationError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_dockerimage_application`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDockerimageApplicationError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_env_by_application_uuid`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateEnvByApplicationUuidError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	Status404(models::InlineObject2),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_private_deploy_key_application`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreatePrivateDeployKeyApplicationError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_private_github_app_application`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreatePrivateGithubAppApplicationError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_public_application`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreatePublicApplicationError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_application_by_uuid`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteApplicationByUuidError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	Status404(models::InlineObject2),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_env_by_application_uuid`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteEnvByApplicationUuidError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	Status404(models::InlineObject2),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`execute_command_application`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExecuteCommandApplicationError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	Status404(models::InlineObject2),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_application_by_uuid`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetApplicationByUuidError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	Status404(models::InlineObject2),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_applications`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListApplicationsError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_envs_by_application_uuid`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListEnvsByApplicationUuidError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	Status404(models::InlineObject2),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`restart_application_by_uuid`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestartApplicationByUuidError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	Status404(models::InlineObject2),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`start_application_by_uuid`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartApplicationByUuidError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	Status404(models::InlineObject2),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stop_application_by_uuid`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StopApplicationByUuidError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	Status404(models::InlineObject2),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_application_by_uuid`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateApplicationByUuidError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	Status404(models::InlineObject2),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_env_by_application_uuid`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateEnvByApplicationUuidError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	Status404(models::InlineObject2),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_envs_by_application_uuid`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateEnvsByApplicationUuidError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	Status404(models::InlineObject2),
	UnknownValue(serde_json::Value),
}
