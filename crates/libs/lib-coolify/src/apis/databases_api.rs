/*
 * Coolify
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, Error};
use crate::{apis::ResponseContent, models};
use async_trait::async_trait;
use reqwest;
use serde::{Deserialize, Serialize};
use std::sync::Arc;

#[async_trait]
pub trait DatabasesApi: Send + Sync {
	async fn create_database_clickhouse<'create_database_clickhouse_request>(
		&self,
		create_database_clickhouse_request: models::CreateDatabaseClickhouseRequest,
	) -> Result<(), Error<CreateDatabaseClickhouseError>>;
	async fn create_database_dragonfly<'create_database_dragonfly_request>(
		&self,
		create_database_dragonfly_request: models::CreateDatabaseDragonflyRequest,
	) -> Result<(), Error<CreateDatabaseDragonflyError>>;
	async fn create_database_keydb<'create_database_keydb_request>(
		&self,
		create_database_keydb_request: models::CreateDatabaseKeydbRequest,
	) -> Result<(), Error<CreateDatabaseKeydbError>>;
	async fn create_database_mariadb<'create_database_mariadb_request>(
		&self,
		create_database_mariadb_request: models::CreateDatabaseMariadbRequest,
	) -> Result<(), Error<CreateDatabaseMariadbError>>;
	async fn create_database_mongodb<'create_database_mongodb_request>(
		&self,
		create_database_mongodb_request: models::CreateDatabaseMongodbRequest,
	) -> Result<(), Error<CreateDatabaseMongodbError>>;
	async fn create_database_mysql<'create_database_mysql_request>(
		&self,
		create_database_mysql_request: models::CreateDatabaseMysqlRequest,
	) -> Result<(), Error<CreateDatabaseMysqlError>>;
	async fn create_database_postgresql<'create_database_postgresql_request>(
		&self,
		create_database_postgresql_request: models::CreateDatabasePostgresqlRequest,
	) -> Result<(), Error<CreateDatabasePostgresqlError>>;
	async fn create_database_redis<'create_database_redis_request>(
		&self,
		create_database_redis_request: models::CreateDatabaseRedisRequest,
	) -> Result<(), Error<CreateDatabaseRedisError>>;
	async fn delete_database_by_uuid<
		'uuid,
		'delete_configurations,
		'delete_volumes,
		'docker_cleanup,
		'delete_connected_networks,
	>(
		&self,
		uuid: &str,
		delete_configurations: Option<bool>,
		delete_volumes: Option<bool>,
		docker_cleanup: Option<bool>,
		delete_connected_networks: Option<bool>,
	) -> Result<
		models::DeleteDatabaseByUuid200Response,
		Error<DeleteDatabaseByUuidError>,
	>;
	async fn get_database_by_uuid<'uuid>(
		&self,
		uuid: &str,
	) -> Result<String, Error<GetDatabaseByUuidError>>;
	async fn list_databases(&self) -> Result<String, Error<ListDatabasesError>>;
	async fn restart_database_by_uuid<'uuid>(
		&self,
		uuid: &str,
	) -> Result<
		models::RestartDatabaseByUuid200Response,
		Error<RestartDatabaseByUuidError>,
	>;
	async fn start_database_by_uuid<'uuid>(
		&self,
		uuid: &str,
	) -> Result<
		models::StartDatabaseByUuid200Response,
		Error<StartDatabaseByUuidError>,
	>;
	async fn stop_database_by_uuid<'uuid>(
		&self,
		uuid: &str,
	) -> Result<models::StopDatabaseByUuid200Response, Error<StopDatabaseByUuidError>>;
	async fn update_database_by_uuid<'uuid, 'update_database_by_uuid_request>(
		&self,
		uuid: &str,
		update_database_by_uuid_request: models::UpdateDatabaseByUuidRequest,
	) -> Result<(), Error<UpdateDatabaseByUuidError>>;
}

pub struct DatabasesApiClient {
	configuration: Arc<configuration::Configuration>,
}

impl DatabasesApiClient {
	pub fn new(configuration: Arc<configuration::Configuration>) -> Self {
		Self { configuration }
	}
}

#[async_trait]
impl DatabasesApi for DatabasesApiClient {
	/// Create a new Clickhouse database.
	async fn create_database_clickhouse<'create_database_clickhouse_request>(
		&self,
		create_database_clickhouse_request: models::CreateDatabaseClickhouseRequest,
	) -> Result<(), Error<CreateDatabaseClickhouseError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str =
			format!("{}/databases/clickhouse", local_var_configuration.base_path);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};
		local_var_req_builder =
			local_var_req_builder.json(&create_database_clickhouse_request);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			Ok(())
		} else {
			let local_var_entity: Option<CreateDatabaseClickhouseError> =
				json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Create a new DragonFly database.
	async fn create_database_dragonfly<'create_database_dragonfly_request>(
		&self,
		create_database_dragonfly_request: models::CreateDatabaseDragonflyRequest,
	) -> Result<(), Error<CreateDatabaseDragonflyError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str =
			format!("{}/databases/dragonfly", local_var_configuration.base_path);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};
		local_var_req_builder =
			local_var_req_builder.json(&create_database_dragonfly_request);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			Ok(())
		} else {
			let local_var_entity: Option<CreateDatabaseDragonflyError> =
				json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Create a new KeyDB database.
	async fn create_database_keydb<'create_database_keydb_request>(
		&self,
		create_database_keydb_request: models::CreateDatabaseKeydbRequest,
	) -> Result<(), Error<CreateDatabaseKeydbError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str =
			format!("{}/databases/keydb", local_var_configuration.base_path);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};
		local_var_req_builder =
			local_var_req_builder.json(&create_database_keydb_request);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			Ok(())
		} else {
			let local_var_entity: Option<CreateDatabaseKeydbError> =
				json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Create a new MariaDB database.
	async fn create_database_mariadb<'create_database_mariadb_request>(
		&self,
		create_database_mariadb_request: models::CreateDatabaseMariadbRequest,
	) -> Result<(), Error<CreateDatabaseMariadbError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str =
			format!("{}/databases/mariadb", local_var_configuration.base_path);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};
		local_var_req_builder =
			local_var_req_builder.json(&create_database_mariadb_request);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			Ok(())
		} else {
			let local_var_entity: Option<CreateDatabaseMariadbError> =
				json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Create a new MongoDB database.
	async fn create_database_mongodb<'create_database_mongodb_request>(
		&self,
		create_database_mongodb_request: models::CreateDatabaseMongodbRequest,
	) -> Result<(), Error<CreateDatabaseMongodbError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str =
			format!("{}/databases/mongodb", local_var_configuration.base_path);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};
		local_var_req_builder =
			local_var_req_builder.json(&create_database_mongodb_request);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			Ok(())
		} else {
			let local_var_entity: Option<CreateDatabaseMongodbError> =
				json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Create a new MySQL database.
	async fn create_database_mysql<'create_database_mysql_request>(
		&self,
		create_database_mysql_request: models::CreateDatabaseMysqlRequest,
	) -> Result<(), Error<CreateDatabaseMysqlError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str =
			format!("{}/databases/mysql", local_var_configuration.base_path);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};
		local_var_req_builder =
			local_var_req_builder.json(&create_database_mysql_request);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			Ok(())
		} else {
			let local_var_entity: Option<CreateDatabaseMysqlError> =
				json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Create a new PostgreSQL database.
	async fn create_database_postgresql<'create_database_postgresql_request>(
		&self,
		create_database_postgresql_request: models::CreateDatabasePostgresqlRequest,
	) -> Result<(), Error<CreateDatabasePostgresqlError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str =
			format!("{}/databases/postgresql", local_var_configuration.base_path);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};
		local_var_req_builder =
			local_var_req_builder.json(&create_database_postgresql_request);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			Ok(())
		} else {
			let local_var_entity: Option<CreateDatabasePostgresqlError> =
				json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Create a new Redis database.
	async fn create_database_redis<'create_database_redis_request>(
		&self,
		create_database_redis_request: models::CreateDatabaseRedisRequest,
	) -> Result<(), Error<CreateDatabaseRedisError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str =
			format!("{}/databases/redis", local_var_configuration.base_path);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};
		local_var_req_builder =
			local_var_req_builder.json(&create_database_redis_request);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			Ok(())
		} else {
			let local_var_entity: Option<CreateDatabaseRedisError> =
				json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Delete database by UUID.
	async fn delete_database_by_uuid<
		'uuid,
		'delete_configurations,
		'delete_volumes,
		'docker_cleanup,
		'delete_connected_networks,
	>(
		&self,
		uuid: &str,
		delete_configurations: Option<bool>,
		delete_volumes: Option<bool>,
		docker_cleanup: Option<bool>,
		delete_connected_networks: Option<bool>,
	) -> Result<
		models::DeleteDatabaseByUuid200Response,
		Error<DeleteDatabaseByUuidError>,
	> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/databases/{uuid}",
			local_var_configuration.base_path,
			uuid = crate::apis::urlencode(uuid)
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

		if let Some(ref local_var_str) = delete_configurations {
			local_var_req_builder = local_var_req_builder
				.query(&[("delete_configurations", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = delete_volumes {
			local_var_req_builder = local_var_req_builder
				.query(&[("delete_volumes", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = docker_cleanup {
			local_var_req_builder = local_var_req_builder
				.query(&[("docker_cleanup", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = delete_connected_networks {
			local_var_req_builder = local_var_req_builder
				.query(&[("delete_connected_networks", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<DeleteDatabaseByUuidError> =
				json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Get database by UUID.
	async fn get_database_by_uuid<'uuid>(
		&self,
		uuid: &str,
	) -> Result<String, Error<GetDatabaseByUuidError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/databases/{uuid}",
			local_var_configuration.base_path,
			uuid = crate::apis::urlencode(uuid)
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::GET, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<GetDatabaseByUuidError> =
				json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// List all databases.
	async fn list_databases(&self) -> Result<String, Error<ListDatabasesError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str =
			format!("{}/databases", local_var_configuration.base_path);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::GET, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<ListDatabasesError> =
				json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Restart database. `Post` request is also accepted.
	async fn restart_database_by_uuid<'uuid>(
		&self,
		uuid: &str,
	) -> Result<
		models::RestartDatabaseByUuid200Response,
		Error<RestartDatabaseByUuidError>,
	> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/databases/{uuid}/restart",
			local_var_configuration.base_path,
			uuid = crate::apis::urlencode(uuid)
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::GET, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<RestartDatabaseByUuidError> =
				json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Start database. `Post` request is also accepted.
	async fn start_database_by_uuid<'uuid>(
		&self,
		uuid: &str,
	) -> Result<
		models::StartDatabaseByUuid200Response,
		Error<StartDatabaseByUuidError>,
	> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/databases/{uuid}/start",
			local_var_configuration.base_path,
			uuid = crate::apis::urlencode(uuid)
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::GET, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<StartDatabaseByUuidError> =
				json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Stop database. `Post` request is also accepted.
	async fn stop_database_by_uuid<'uuid>(
		&self,
		uuid: &str,
	) -> Result<models::StopDatabaseByUuid200Response, Error<StopDatabaseByUuidError>>
	{
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/databases/{uuid}/stop",
			local_var_configuration.base_path,
			uuid = crate::apis::urlencode(uuid)
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::GET, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<StopDatabaseByUuidError> =
				json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Update database by UUID.
	async fn update_database_by_uuid<'uuid, 'update_database_by_uuid_request>(
		&self,
		uuid: &str,
		update_database_by_uuid_request: models::UpdateDatabaseByUuidRequest,
	) -> Result<(), Error<UpdateDatabaseByUuidError>> {
		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/databases/{uuid}",
			local_var_configuration.base_path,
			uuid = crate::apis::urlencode(uuid)
		);
		let mut local_var_req_builder = local_var_client
			.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder
				.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_token) =
			local_var_configuration.bearer_access_token
		{
			local_var_req_builder =
				local_var_req_builder.bearer_auth(local_var_token.to_owned());
		};
		local_var_req_builder =
			local_var_req_builder.json(&update_database_by_uuid_request);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error()
		{
			Ok(())
		} else {
			let local_var_entity: Option<UpdateDatabaseByUuidError> =
				json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}
}

/// struct for typed errors of method [`create_database_clickhouse`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDatabaseClickhouseError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	UnknownValue(json::Value),
}

/// struct for typed errors of method [`create_database_dragonfly`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDatabaseDragonflyError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	UnknownValue(json::Value),
}

/// struct for typed errors of method [`create_database_keydb`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDatabaseKeydbError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	UnknownValue(json::Value),
}

/// struct for typed errors of method [`create_database_mariadb`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDatabaseMariadbError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	UnknownValue(json::Value),
}

/// struct for typed errors of method [`create_database_mongodb`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDatabaseMongodbError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	UnknownValue(json::Value),
}

/// struct for typed errors of method [`create_database_mysql`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDatabaseMysqlError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	UnknownValue(json::Value),
}

/// struct for typed errors of method [`create_database_postgresql`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDatabasePostgresqlError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	UnknownValue(json::Value),
}

/// struct for typed errors of method [`create_database_redis`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDatabaseRedisError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	UnknownValue(json::Value),
}

/// struct for typed errors of method [`delete_database_by_uuid`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDatabaseByUuidError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	Status404(models::InlineObject2),
	UnknownValue(json::Value),
}

/// struct for typed errors of method [`get_database_by_uuid`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDatabaseByUuidError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	Status404(models::InlineObject2),
	UnknownValue(json::Value),
}

/// struct for typed errors of method [`list_databases`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListDatabasesError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	UnknownValue(json::Value),
}

/// struct for typed errors of method [`restart_database_by_uuid`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RestartDatabaseByUuidError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	Status404(models::InlineObject2),
	UnknownValue(json::Value),
}

/// struct for typed errors of method [`start_database_by_uuid`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartDatabaseByUuidError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	Status404(models::InlineObject2),
	UnknownValue(json::Value),
}

/// struct for typed errors of method [`stop_database_by_uuid`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StopDatabaseByUuidError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	Status404(models::InlineObject2),
	UnknownValue(json::Value),
}

/// struct for typed errors of method [`update_database_by_uuid`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDatabaseByUuidError {
	Status401(models::InlineObject1),
	Status400(models::InlineObject),
	Status404(models::InlineObject2),
	UnknownValue(json::Value),
}
